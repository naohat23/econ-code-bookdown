[["rの基本的な使用方法.html", "2 Rの基本的な使用方法 2.1 第2章の準備 2.2 主要ショートカットキー 2.3 基本操作 2.4 演算 2.5 ベクトル 2.6 行列 2.7 データフレーム 2.8 リスト 2.9 文字列操作 2.10 制御構文 2.11 ファイル操作 2.12 データの読み込み・書き出し 2.13 オブジェクトのセーブ・ロード", " 2 Rの基本的な使用方法 第2章「Rの基本的な使用方法」では、Rの基本的な使用方法について解説します。本節の内容は基礎部分のみのため、詳細は、馬場（2020）、松村 他（2021）、Wickham &amp; Grolemund（2017）などを参照してください。 RStudioでコードを編集するパネルをソース（Source）と呼びます。RStudioの左上のパネルがソースで、コンソール（Console）パネルの上にあります。ソースが表示されていない場合は、FileメニューからNew Fileに進み、R Scriptを選択すると、ソースが表示されます。 ソースにコードを記述し、記述したコードの行にカーソルがある状態でCtrl + Enterを押すと、コンソールに実行結果が表示されます。 2.1 第2章の準備 パッケージのインポート library(magrittr) library(tidyverse) library(openxlsx) 2.2 主要ショートカットキー Alt + Shift + K： キーボードショートカットを表示 編集 Ctrl + S： 保存 Ctrl + A： すべて選択 Ctrl + Shift + R： セクション区切りを挿入 Ctrl + Shift + C： 選択範囲をコメントアウト／コメントアウト解除 Ctrl + Shift + M： パイプオペレータ%&gt;%を挿入 実行 Ctrl + Enter： カーソルがある行／選択している部分のコードを実行 Ctrl + Alt + T： カーソルがあるセクションのコードをすべて実行 Ctrl + Alt + R： すべてのコードを実行 その他 F1： カーソルがある関数のヘルプを表示 2.3 基本操作 # 代入は &lt;- か = x &lt;- 2 x ## [1] 2 # シャープでコメントアウト（実行されない） 2.4 演算 四則計算 # 足し算 1 + 1 ## [1] 2 # 引き算 3 - 1 ## [1] 2 # 掛け算 2 * 3 ## [1] 6 # 割り算 10 / 5 ## [1] 2 # 割り算の整数の商 10 %/% 3 ## [1] 3 # 割り算の余り 10 %% 3 ## [1] 1 # べき乗 3 ** 2 ## [1] 9 3 ^ 2 ## [1] 9 数値計算 # 自然対数 log(10) ## [1] 2.302585 # ネイピア数のべき乗 exp(1) ## [1] 2.718282 # 平方根 sqrt(2) ## [1] 1.414214 # 絶対値 abs(-5) ## [1] 5 一致・大小関係 # 一致 2 == 2 ## [1] TRUE # 不一致 3 != 2 ## [1] TRUE # より大きい 3 &gt; 2 ## [1] TRUE # 以上 3 &gt;= 3 ## [1] TRUE # より小さい 2 &lt; 3 ## [1] TRUE # 以下 2 &lt;= 2 ## [1] TRUE 包含・集合関係 # 包含関係 1:5 %in% c(1, 2, 5) ## [1] TRUE TRUE FALSE FALSE TRUE # 和集合 union(seq(0, 20, 2), seq(0, 20, 3)) ## [1] 0 2 4 6 8 10 12 14 16 18 20 3 9 15 # 共通部分 intersect(seq(0, 20, 2), seq(0, 20, 3)) ## [1] 0 6 12 18 # 差分 setdiff(seq(0, 20, 2), seq(0, 20, 3)) ## [1] 2 4 8 10 14 16 20 2.5 ベクトル ベクトルの作成 ベクトルは複数の要素を一つにまとめたデータ構造で、c()関数で作成します。一つのベクトルには単一のデータ型のみ格納でき、数値型や文字列型のデータを混在させることはできません。 # 数値型ベクトルの作成 vec_1 &lt;- c(11, 12, 13, 14, 15) vec_1 ## [1] 11 12 13 14 15 # 文字列型ベクトルの作成 vec_2 &lt;- c(&quot;Hello&quot;, &quot;World&quot;) vec_2 ## [1] &quot;Hello&quot; &quot;World&quot; # 数値型データと文字列型データを混在させると、すべて文字列型に変換される c(1, 2, &quot;A&quot;, &quot;B&quot;) ## [1] &quot;1&quot; &quot;2&quot; &quot;A&quot; &quot;B&quot; ベクトル要素へのアクセス ベクトルでは、ベクトル[要素のインデックス]の形でインデックスを指定して各要素にアクセスすることができます。なお、Pythonなど他のプログラミング言語のインデックスは0から始まりますが、Rのインデックスは1から始まる点に注意してください。 # ベクトルの要素へのアクセス vec_1[1] ## [1] 11 vec_1[5] ## [1] 15 vec_1[2:4] ## [1] 12 13 14 rev(vec_1)[1] ## [1] 15 規則性があるベクトルの作成 規則性があるベクトルを作成するには、コロン（:）、seq()関数、rep()関数を使用します。 # 1から10までの等差数列 1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 # 0から20までの2つ置きの数列 seq(from = 0, to = 20, by = 2) ## [1] 0 2 4 6 8 10 12 14 16 18 20 # 1から10までを4等分する等差数列 seq(from = 1, to = 10, length.out = 4) ## [1] 1 4 7 10 # 要素の繰り返し rep(x = 2, times = 5) ## [1] 2 2 2 2 2 # ベクトルの繰り返し rep(x = c(1, 2), times = 3) ## [1] 1 2 1 2 1 2 # ベクトルの各要素の繰り返し rep(x = c(1, 2), each = 3) ## [1] 1 1 1 2 2 2 ベクトルの演算 ベクトルの演算を行うと、ベクトルの対応する要素どうしが計算され、計算結果としてベクトルが出力されます。ベクトルの長さが異なる場合は、短い方のベクトルが使いまわされて長さを合わせます。 *演算子はベクトルの要素どうしの掛け算を行う点に注意してください。ベクトルの内積を計算するには%*%演算子を使用します。 vec_3 &lt;- c(1, 2, 3) vec_4 &lt;- c(5, 6, 7) # ベクトル要素の足し算 vec_3 + vec_4 ## [1] 6 8 10 # ベクトル要素の引き算 vec_3 - vec_4 ## [1] -4 -4 -4 # ベクトル要素の掛け算 vec_3 * vec_4 ## [1] 5 12 21 # ベクトル要素の割り算 vec_3 / vec_4 ## [1] 0.2000000 0.3333333 0.4285714 # ベクトルの内積 vec_3 %*% vec_4 ## [,1] ## [1,] 38 2.6 行列 行列の作成 行列はmatrix()関数を使用し、ベクトルを複数の列・行に分割する形で作成します。 # ベクトルを複数列に分割して行列を作成 mat_1 &lt;- matrix( data = 1:10, ncol = 2 ) mat_1 ## [,1] [,2] ## [1,] 1 6 ## [2,] 2 7 ## [3,] 3 8 ## [4,] 4 9 ## [5,] 5 10 # ベクトルを複数行に分割して行列を作成 mat_2 &lt;- matrix( data = 1:10, nrow = 2 ) mat_2 ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 3 5 7 9 ## [2,] 2 4 6 8 10 行列の要素へのアクセス 行列の要素にアクセスするには、ベクトルと同様に行列[要素の行インデックス, 要素の列インデックス]の形でインデックスを指定します。 # 行列の3行目・1列目の要素を取得 mat_1[3, 1] ## [1] 3 # 行列の4行目全体を取得 mat_1[4, ] ## [1] 4 9 # 行列の2列目全体を取得 mat_1[, 2] ## [1] 6 7 8 9 10 # 行列の1～3行目を取得 mat_1[1:3, ] ## [,1] [,2] ## [1,] 1 6 ## [2,] 2 7 ## [3,] 3 8 # 行列の1～3行目以外を取得 mat_1[-1:-3, ] ## [,1] [,2] ## [1,] 4 9 ## [2,] 5 10 行列の演算 行列の演算を行うと、行列の対応する要素どうしが計算され、計算結果として行列が出力されます。 *演算子は行列の要素どうしの掛け算を行う点に注意してください。行列の積を計算するには%*%演算子を使用します。 mat_2 &lt;- matrix( data = 1:4, ncol = 2 ) mat_3 &lt;- matrix( data = 5:8, ncol = 2 ) # 行列要素の足し算 mat_2 + mat_3 ## [,1] [,2] ## [1,] 6 10 ## [2,] 8 12 # 行列要素の引き算 mat_2 - mat_3 ## [,1] [,2] ## [1,] -4 -4 ## [2,] -4 -4 # 行列要素の掛け算 mat_2 * mat_3 ## [,1] [,2] ## [1,] 5 21 ## [2,] 12 32 # 行列要素の割り算 mat_2 / mat_3 ## [,1] [,2] ## [1,] 0.2000000 0.4285714 ## [2,] 0.3333333 0.5000000 # 各行の和 rowSums(mat_2) ## [1] 4 6 # 各列の和 colSums(mat_2) ## [1] 3 7 # 行列の積 mat_2 %*% mat_3 ## [,1] [,2] ## [1,] 23 31 ## [2,] 34 46 # 行列の転置 t(mat_2) ## [,1] [,2] ## [1,] 1 2 ## [2,] 3 4 # 逆行列 solve(mat_2) ## [,1] [,2] ## [1,] -2 1.5 ## [2,] 1 -0.5 2.7 データフレーム データフレームは、同じ長さの列ベクトルを複数まとめた行列形式のデータ構造で、実務で最も頻繁に使用します。Excelのスプレッドシートのイメージに近く、実際にCSV形式のファイルをRに読み込むとデータフレーム形式のオブジェクトが作成されます。 なお、データフレームには、Rにもともと備わっているdata.frame形式と、tidyverseパッケージによって導入されたtibble形式の2種類があります。両者にはいくつか違いがありますが、data.frame形式を使いやすくしたものがtibble形式と言えます。詳細はtibbleパッケージの公式ウェブサイトを参照してください。 データフレームの作成 tibble形式のデータフレームは、tibble()関数を使用して列名 = 要素の形で作成します。データフレームではすべての列ベクトルの要素数が同じになるようにします。 df_1 &lt;- tibble( x = 1:5, y = 6:10, z = x ^ 2 + y ) df_1 ## # A tibble: 5 × 3 ## x y z ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1 6 7 ## 2 2 7 11 ## 3 3 8 17 ## 4 4 9 25 ## 5 5 10 35 データフレームの要素へのアクセス データフレームでは、データフレーム$列名の形でドルマークを使用して各列ベクトルにアクセスすることができます。また、データフレーム$列名[要素インデックス]で各列ベクトルの要素にアクセスできます。 df_1$x ## [1] 1 2 3 4 5 df_1$z[3] ## [1] 17 その他に、角括弧を使用して要素にアクセスすることもできます。ここで、一重の角括弧と二重の角括弧では実行結果が異なる点に注意してください。一重角括弧では、データフレームの一部を分割したものとして、結果がtibble形式で出力されます。一方、二重角括弧では、tibble形式の中に格納されているベクトルや単一の数値といった要素そのものが出力されます。 df_1[&quot;x&quot;] ## # A tibble: 5 × 1 ## x ## &lt;int&gt; ## 1 1 ## 2 2 ## 3 3 ## 4 4 ## 5 5 df_1[1] ## # A tibble: 5 × 1 ## x ## &lt;int&gt; ## 1 1 ## 2 2 ## 3 3 ## 4 4 ## 5 5 df_1[2, 2] ## # A tibble: 1 × 1 ## y ## &lt;int&gt; ## 1 7 df_1[[&quot;x&quot;]] ## [1] 1 2 3 4 5 df_1[[1]] ## [1] 1 2 3 4 5 df_1[[2, 2]] ## [1] 7 その他のデータフレームの機能 df_2 &lt;- tibble( letters = LETTERS, numbers = 1:26 ) df_2 ## # A tibble: 26 × 2 ## letters numbers ## &lt;chr&gt; &lt;int&gt; ## 1 A 1 ## 2 B 2 ## 3 C 3 ## 4 D 4 ## 5 E 5 ## 6 F 6 ## 7 G 7 ## 8 H 8 ## 9 I 9 ## 10 J 10 ## # … with 16 more rows # データフレームの上部のみ表示 head(df_2) ## # A tibble: 6 × 2 ## letters numbers ## &lt;chr&gt; &lt;int&gt; ## 1 A 1 ## 2 B 2 ## 3 C 3 ## 4 D 4 ## 5 E 5 ## 6 F 6 # データフレームの下部のみ表示 tail(df_2) ## # A tibble: 6 × 2 ## letters numbers ## &lt;chr&gt; &lt;int&gt; ## 1 U 21 ## 2 V 22 ## 3 W 23 ## 4 X 24 ## 5 Y 25 ## 6 Z 26 # データフレームの列名（変数）一覧を出力 colnames(df_2) ## [1] &quot;letters&quot; &quot;numbers&quot; # データフレームの列名（変数）と内容の一覧を出力 str(df_2) ## tibble [26 × 2] (S3: tbl_df/tbl/data.frame) ## $ letters: chr [1:26] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; ... ## $ numbers: int [1:26] 1 2 3 4 5 6 7 8 9 10 ... 2.8 リスト リストは、単一の数値、文字列、ベクトル、データフレームなど、様々な種類のデータを格納することができる容器のようなものです。リストそのものをリストに格納することもできます。リストはlist()関数で作成します。リストに格納する各要素には、それぞれ名前を付けることができます。 リストの作成 list_1 &lt;- list( number = 1, string = &quot;a&quot;, vector = c(10, 11, 12), matrix = matrix(1:9, ncol = 3) ) list_1 ## $number ## [1] 1 ## ## $string ## [1] &quot;a&quot; ## ## $vector ## [1] 10 11 12 ## ## $matrix ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 リストの要素へのアクセス リストでは、データフレームと同様にリスト$要素名の形でドルマークを使用して各要素にアクセスすることができます。 list_1$number ## [1] 1 list_1$matrix ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 また、ベクトルや行列と同様に、リスト[[要素インデックス]]でも各要素にアクセスすることができます。ここで、角括弧が二重である点に注意してください。 list_1[[3]] ## [1] 10 11 12 2.9 文字列操作 Rでは、tidyverseに含まれるstringrパッケージを使用して、様々な文字列操作を行うことができます。 stringrパッケージの文字列操作関数は、複数の文字列型データを格納したベクトル形式のデータ構造（データフレームの列など）に対し、一括して文字列操作の処理を適用することを念頭に設計されています。これにより、forループなどを使用することなく、複数の文字列に対する操作を高速に実行することができます。 文字列の連結 複数の文字列を連結するにはstr_c()関数を使用します。 # 単語を連結 str_c(&quot;日本&quot;, &quot;の&quot;, &quot;GDP&quot;, &quot;成長率&quot;, &quot;は&quot;, &quot;2％&quot;) ## [1] &quot;日本のGDP成長率は2％&quot; # 区切り文字を使用して単語を連結 str_c(&quot;directory&quot;, &quot;subdirectory&quot;, &quot;file&quot;, sep = &quot;/&quot;) ## [1] &quot;directory/subdirectory/file&quot; # 文字列ベクトルと単一文字列を連結 str_c(c(&quot;日本&quot;, &quot;米国&quot;, &quot;欧州&quot;), &quot;の成長率&quot;) ## [1] &quot;日本の成長率&quot; &quot;米国の成長率&quot; &quot;欧州の成長率&quot; # 文字列ベクトルに格納されている複数の文字列を連結 str_c(c(&quot;日本&quot;, &quot;米国&quot;, &quot;欧州&quot;), collapse = &quot;&quot;) ## [1] &quot;日本米国欧州&quot; 文字列の切り出し 文字列から一部を切り出すには、str_sub()関数を使用し、切り出す箇所の開始・終了位置（文字数）を指定します。 str_sub(string = c(&quot;日本の成長率&quot;, &quot;米国の成長率&quot;, &quot;欧州の成長率&quot;), # 切り出す対象の文字列／文字列ベクトル start = 1, # 開始位置の文字数 end = 2 # 終了位置の文字数 ) ## [1] &quot;日本&quot; &quot;米国&quot; &quot;欧州&quot; 文字列の検出・置換 ある文字列を含んでいるかを検出するには、str_detect()関数を使用し、pattern引数に検出条件を指定します。str_detect()関数は検出結果に応じてTRUEかFALSEを出力します。 str_detect(string = c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;, &quot;pinapple&quot;), # 検出対象の文字列ベクトル pattern = &quot;e&quot; # 検出条件 ) ## [1] TRUE FALSE TRUE TRUE より複雑な条件で文字列を検出する場合は、文字列ベクトルを変数としたデータフレームにstr_detect()関数を適用するのがよいでしょう。 具体的には、データフレームの行をフィルタするdplyr::filter()関数の中でstr_detect()関数を使用して、検出条件に合致するデータを抽出します。なお、データフレームの操作に関する詳細は、第3章「tidyverseによるデータ操作」を参照してください。 ここでは、都道府県名の変数をもつデータフレームをサンプルデータとして作成し、str_detect()関数を用いてデータの抽出を行います。 # サンプルデータを作成 data_pref_names &lt;- tibble::tibble( pref_index = 1:47, pref_name = c(&quot;北海道&quot;, &quot;青森県&quot;, &quot;岩手県&quot;, &quot;宮城県&quot;, &quot;秋田県&quot;, &quot;山形県&quot;, &quot;福島県&quot;, &quot;茨城県&quot;, &quot;栃木県&quot;, &quot;群馬県&quot;, &quot;埼玉県&quot;, &quot;千葉県&quot;, &quot;東京都&quot;, &quot;神奈川県&quot;, &quot;新潟県&quot;, &quot;富山県&quot;, &quot;石川県&quot;, &quot;福井県&quot;, &quot;山梨県&quot;, &quot;長野県&quot;, &quot;岐阜県&quot;, &quot;静岡県&quot;, &quot;愛知県&quot;, &quot;三重県&quot;, &quot;滋賀県&quot;, &quot;京都府&quot;, &quot;大阪府&quot;, &quot;兵庫県&quot;, &quot;奈良県&quot;, &quot;和歌山県&quot;, &quot;鳥取県&quot;, &quot;島根県&quot;, &quot;岡山県&quot;, &quot;広島県&quot;, &quot;山口県&quot;, &quot;徳島県&quot;, &quot;香川県&quot;, &quot;愛媛県&quot;, &quot;高知県&quot;, &quot;福岡県&quot;, &quot;佐賀県&quot;, &quot;長崎県&quot;, &quot;熊本県&quot;, &quot;大分県&quot;, &quot;宮崎県&quot;, &quot;鹿児島県&quot;, &quot;沖縄県&quot;) ) # 単一文字列を検出 data_pref_names %&gt;% dplyr::filter(str_detect(string = pref_name, pattern = &quot;県&quot;)) ## # A tibble: 43 × 2 ## pref_index pref_name ## &lt;int&gt; &lt;chr&gt; ## 1 2 青森県 ## 2 3 岩手県 ## 3 4 宮城県 ## 4 5 秋田県 ## 5 6 山形県 ## 6 7 福島県 ## 7 8 茨城県 ## 8 9 栃木県 ## 9 10 群馬県 ## 10 11 埼玉県 ## # … with 33 more rows # 複数文字列をor条件で検出するには、|演算子を使用 data_pref_names %&gt;% dplyr::filter(str_detect(string = pref_name, pattern = &quot;都|府&quot;)) ## # A tibble: 3 × 2 ## pref_index pref_name ## &lt;int&gt; &lt;chr&gt; ## 1 13 東京都 ## 2 26 京都府 ## 3 27 大阪府 # 複数文字列をand条件で検出するには、str_detect()関数を&amp;演算子で連結 data_pref_names %&gt;% dplyr::filter(str_detect(string = pref_name, pattern = &quot;都&quot;) &amp; str_detect(string = pref_name, pattern = &quot;府&quot;)) ## # A tibble: 1 × 2 ## pref_index pref_name ## &lt;int&gt; &lt;chr&gt; ## 1 26 京都府 文字列の置換はstr_replace()関数で行います。置換の該当箇所が複数ある場合、最初の該当箇所のみ置換する場合はstr_replace()関数を、すべての該当箇所を置換する場合はstr_replace_all()関数を使用します。どちらの関数も、pattern引数に置換元の文字列を、replacement引数に置換先の文字列を指定します。 複数の「置換元文字列＆置換先文字列」の組み合わせを設定する場合は、pattern引数に名前付きベクトルc(\"pattern1\" = \"replacement1\", \"pattern2\" = \"replacement2\")の形で「置換元文字列＆置換先文字列」の組み合わせを指定します。 なお、置換先の文字列として、何もない文字列（ダブルクオーテーションの中に何も含まない文字列\"\"）を指定すると、置換元の文字列を削除したことと同じ処理になります。 # 都道府県名一覧の&quot;県&quot;を&quot;&quot;で置換（削除） str_replace_all(string = data_pref_names$pref_name, # 置換対象の文字列 pattern = &quot;県&quot;, # 置換元の文字列 replacement = &quot;&quot; # 置換先の文字列 ) ## [1] &quot;北海道&quot; &quot;青森&quot; &quot;岩手&quot; &quot;宮城&quot; &quot;秋田&quot; &quot;山形&quot; &quot;福島&quot; &quot;茨城&quot; ## [9] &quot;栃木&quot; &quot;群馬&quot; &quot;埼玉&quot; &quot;千葉&quot; &quot;東京都&quot; &quot;神奈川&quot; &quot;新潟&quot; &quot;富山&quot; ## [17] &quot;石川&quot; &quot;福井&quot; &quot;山梨&quot; &quot;長野&quot; &quot;岐阜&quot; &quot;静岡&quot; &quot;愛知&quot; &quot;三重&quot; ## [25] &quot;滋賀&quot; &quot;京都府&quot; &quot;大阪府&quot; &quot;兵庫&quot; &quot;奈良&quot; &quot;和歌山&quot; &quot;鳥取&quot; &quot;島根&quot; ## [33] &quot;岡山&quot; &quot;広島&quot; &quot;山口&quot; &quot;徳島&quot; &quot;香川&quot; &quot;愛媛&quot; &quot;高知&quot; &quot;福岡&quot; ## [41] &quot;佐賀&quot; &quot;長崎&quot; &quot;熊本&quot; &quot;大分&quot; &quot;宮崎&quot; &quot;鹿児島&quot; &quot;沖縄&quot; # 都道府県名一覧の&quot;県&quot;、&quot;都&quot;、&quot;府&quot;を&quot;&quot;で置換（削除） # この場合、&quot;京都府&quot;の&quot;都&quot;と&quot;府&quot;が置換されるため、適切でない str_replace_all(string = data_pref_names$pref_name, # 置換対象の文字列 pattern = c(&quot;県&quot; = &quot;&quot;, &quot;都&quot; = &quot;&quot;, &quot;府&quot; = &quot;&quot;) # 複数の置換条件を格納した名前付きベクトル ) ## [1] &quot;北海道&quot; &quot;青森&quot; &quot;岩手&quot; &quot;宮城&quot; &quot;秋田&quot; &quot;山形&quot; &quot;福島&quot; &quot;茨城&quot; ## [9] &quot;栃木&quot; &quot;群馬&quot; &quot;埼玉&quot; &quot;千葉&quot; &quot;東京&quot; &quot;神奈川&quot; &quot;新潟&quot; &quot;富山&quot; ## [17] &quot;石川&quot; &quot;福井&quot; &quot;山梨&quot; &quot;長野&quot; &quot;岐阜&quot; &quot;静岡&quot; &quot;愛知&quot; &quot;三重&quot; ## [25] &quot;滋賀&quot; &quot;京&quot; &quot;大阪&quot; &quot;兵庫&quot; &quot;奈良&quot; &quot;和歌山&quot; &quot;鳥取&quot; &quot;島根&quot; ## [33] &quot;岡山&quot; &quot;広島&quot; &quot;山口&quot; &quot;徳島&quot; &quot;香川&quot; &quot;愛媛&quot; &quot;高知&quot; &quot;福岡&quot; ## [41] &quot;佐賀&quot; &quot;長崎&quot; &quot;熊本&quot; &quot;大分&quot; &quot;宮崎&quot; &quot;鹿児島&quot; &quot;沖縄&quot; # 都道府県名一覧の&quot;県&quot;、&quot;都&quot;、&quot;府&quot;を&quot;&quot;で置換（削除）する正しい処理 str_replace_all(string = data_pref_names$pref_name, # 置換対象の文字列 pattern = c(&quot;県&quot; = &quot;&quot;, &quot;東京都&quot; = &quot;東京&quot;, &quot;府&quot; = &quot;&quot;) # 複数の置換条件を格納した名前付きベクトル ) ## [1] &quot;北海道&quot; &quot;青森&quot; &quot;岩手&quot; &quot;宮城&quot; &quot;秋田&quot; &quot;山形&quot; &quot;福島&quot; &quot;茨城&quot; ## [9] &quot;栃木&quot; &quot;群馬&quot; &quot;埼玉&quot; &quot;千葉&quot; &quot;東京&quot; &quot;神奈川&quot; &quot;新潟&quot; &quot;富山&quot; ## [17] &quot;石川&quot; &quot;福井&quot; &quot;山梨&quot; &quot;長野&quot; &quot;岐阜&quot; &quot;静岡&quot; &quot;愛知&quot; &quot;三重&quot; ## [25] &quot;滋賀&quot; &quot;京都&quot; &quot;大阪&quot; &quot;兵庫&quot; &quot;奈良&quot; &quot;和歌山&quot; &quot;鳥取&quot; &quot;島根&quot; ## [33] &quot;岡山&quot; &quot;広島&quot; &quot;山口&quot; &quot;徳島&quot; &quot;香川&quot; &quot;愛媛&quot; &quot;高知&quot; &quot;福岡&quot; ## [41] &quot;佐賀&quot; &quot;長崎&quot; &quot;熊本&quot; &quot;大分&quot; &quot;宮崎&quot; &quot;鹿児島&quot; &quot;沖縄&quot; 文字列のパディング パディングとは、固定長の文字列を扱う際に、文字数（桁数）が足りない部分を埋めることです。主に、ファイルやオブジェクトの名称に数字で連番をつける時に用います。パディングにはstr_pad()関数を使用します。 # 数字の左側にゼロをパディングして3桁にする str_pad(string = 1:20, # 元の文字列（ここでは数値ベクトルを指定） width = 3, # 桁数 pad = &quot;0&quot;, # パディングに使用する文字 side = &quot;left&quot; # パディングする側 ) ## [1] &quot;001&quot; &quot;002&quot; &quot;003&quot; &quot;004&quot; &quot;005&quot; &quot;006&quot; &quot;007&quot; &quot;008&quot; &quot;009&quot; &quot;010&quot; &quot;011&quot; &quot;012&quot; ## [13] &quot;013&quot; &quot;014&quot; &quot;015&quot; &quot;016&quot; &quot;017&quot; &quot;018&quot; &quot;019&quot; &quot;020&quot; # ファイル名に1～12の2桁連番を追加する例 str_c(&quot;file_&quot;, str_pad(string = 1:12, width = 2, pad = &quot;0&quot;)) ## [1] &quot;file_01&quot; &quot;file_02&quot; &quot;file_03&quot; &quot;file_04&quot; &quot;file_05&quot; &quot;file_06&quot; &quot;file_07&quot; ## [8] &quot;file_08&quot; &quot;file_09&quot; &quot;file_10&quot; &quot;file_11&quot; &quot;file_12&quot; 2.10 制御構文 制御構文には、条件分岐を行うifやelse、同じ操作の繰り返しを行うforやwhile、エラー処理を行うtryがあります。 if/else文 if文は、if (条件) {処理}の形で記述します。else ifで追加条件、elseで「その他すべて」の条件を意味します。 x &lt;- 5 if (x &lt; 2) { print(&quot;A&quot;) } else if (x &gt;= 2 &amp; x &lt; 6) { print(&quot;B&quot;) } else { print(&quot;C&quot;) } ## [1] &quot;B&quot; forループ for文は、for (変数 in 変数に逐次代入する要素) {処理}の形で記述します。変数はカウンタではない点に注意してください。 for (i in 1:5) { print(i) } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 for (letter in letters[1:6]) { print(letter) } ## [1] &quot;a&quot; ## [1] &quot;b&quot; ## [1] &quot;c&quot; ## [1] &quot;d&quot; ## [1] &quot;e&quot; ## [1] &quot;f&quot; 変数をカウンタとして使用したい場合は、seq_along()関数をfor (変数 in seq_along(変数に逐次代入する要素を格納したベクトル等))の形で用いると、自動的に要素数に応じたインデックスを変数に代入してくれます。 for (i in seq_along(letters[1:6])) { print(str_c(i, &quot;_&quot;, letters[1:6][i])) } ## [1] &quot;1_a&quot; ## [1] &quot;2_b&quot; ## [1] &quot;3_c&quot; ## [1] &quot;4_d&quot; ## [1] &quot;5_e&quot; ## [1] &quot;6_f&quot; whileループ while文は、while (繰り返し処理を続ける条件) {処理}の形で記述します。while文を使う際は、「繰り返し処理を続ける条件」が有限回数で終わるように処理内容を工夫します（そうしないと無限ループになります）。例えば、下記のように条件を「カウンタが正の値」にしておき、処理の中でカウンタが減少するように書くのが一般的です。 count &lt;- 3 while (count &gt; 0) { print(count) count &lt;- count - 1 } ## [1] 3 ## [1] 2 ## [1] 1 breakによる繰り返しの終了 while文の処理の中でbreak()関数を用い、ループを強制的に終了させることができます。 vec_break &lt;- c(10, 20, 30, 40, 50) index &lt;- 1 while (TRUE) { # indexがvec_breakの要素数を超えると繰り返しを終了 if (index &gt; length(vec_break)) { break() } print(vec_break[index]) index &lt;- index + 1 } ## [1] 10 ## [1] 20 ## [1] 30 ## [1] 40 ## [1] 50 nextによる処理のスキップ for文やwhile文の中でnest()関数を用いると、処理をスキップして次の処理に移ります。 for (i in 1:5) { # iが3のとき処理をスキップ if (i == 3) next() print(i) } ## [1] 1 ## [1] 2 ## [1] 4 ## [1] 5 tryによるエラー処理 エラーを起こす可能性がある処理をtry()関数のexpr = {}内に記述することで、エラーが発生しても処理を続けることができます。 list_try &lt;- list(1, 2, 3, &quot;4&quot;, 5) for (i in seq_along(list_try)) { try( expr = { # エラーの可能性がある処理 x &lt;- log(list_try[[i]]) print(x) }, silent = FALSE # TRUEにするとエラーの内容を非表示 ) } ## [1] 0 ## [1] 0.6931472 ## [1] 1.098612 ## Error in log(list_try[[i]]) : ## non-numeric argument to mathematical function ## [1] 1.609438 2.11 ファイル操作 Rでは、ファイル操作関数を使用してディレクトリ（フォルダ）やファイルを直接操作することができます。 なお、WindowsやPythonではディレクトリの階層を表す記号としてバックスラッシュ：\\（日本語環境では円マークとして表示される場合もある）を用いますが、Rではスラッシュ：/を用いますので、注意してください。 ディレクトリ関連 # 作業ディレクトリの指定 setwd(dir = &quot;directory&quot;) # 作業ディレクトリのパスを出力 getwd() # ディレクトリを新規作成 dir.create(path = &quot;./directory&quot;) ファイル関連 # ディレクトリの中にあるファイル一覧を出力 list.files(path = &quot;directory&quot;) # ファイルのコピー file.copy(from = &quot;directory/file_1.csv&quot;, to = &quot;directory/file_2.csv&quot; ) ファイルのダウンロード ウェブからファイルをダウンロードする場合は、download.file()関数を使用します。プロキシ環境ではあらかじめプロキシ設定を行ってください。 download.file(url = &quot;https://www.sample.com/file.csv&quot;, # ダウンロード元のURL destfile = &quot;directory/file.csv&quot; # ダウンロードしたファイルを格納するファイルパス ) 制御構文のforループなどと組み合わせると、複数のファイルを自動でダウンロードできます。ただし、ダウンロード元のサーバーに過度な負荷をかけないよう、Sys.sleep()関数でスリープタイムを設定しておきましょう。 # forループで複数のファイルを自動ダウンロードする例 website &lt;- &quot;https://www.sample.com/&quot; file_name &lt;- &quot;file&quot; file_nums &lt;- 1:3 for (i in file_nums) { url &lt;- str_c(website, file_name, &quot;_&quot;, i, &quot;.csv&quot;), destfile &lt;- str_c(&quot;directory/&quot;, file_name, &quot;_&quot;, str_pad(i, width = 2, pad = &quot;0&quot;), &quot;.csv&quot;) download.file(url = url, destfile = destfile) Sys.sleep(time = 1) # スリープタイム（指定した秒数の間、処理を停止） } 2.12 データの読み込み・書き出し CSVデータの読み込み CSVデータの読み込みには、readrパッケージのread_csv()関数を使用します。ローカルネットワークのファイルパス、ウェブのURLどちらからの読み込みにも対応しています。 CSVが使用している文字コードにより文字化けする場合あるため、locale引数で適切な文字コードを指定してください。 data &lt;- readr::read_csv(file = &quot;directory/file.csv&quot;, # ファイルパス／URL（拡張子が必要） col_names = TRUE, # ヘッダー（列名データ）の有無／列名指定 col_types = NULL, # 各列の型の指定（c：文字列型、d：数値型、D：日付型、l：論理値型） col_select = NULL, # 読み込む列の指定（列名、インデックス） skip = 0, # 読み込み時に上からスキップする行数 locale = locale(encoding = &quot;CP932&quot;) # Windows標準（Shift JIS）で作成されたファイルは&quot;CP932&quot;、utf-8で作成されたファイルは&quot;UTF-8&quot; ) CSVファイルにおけるデータの区切り文字はカンマ「,」ですが、中には区切り文字としてカンマ以外の文字（例えばセミコロン「;」など）が使われている場合もあります。そうした特殊はCSVファイルはread_csv()関数では上手く読み込めないことがあるため、その際はread_delim()関数を使用し、delim引数に区切り文字を指定します。 data &lt;- readr::read_delim(file = &quot;directory/file.csv&quot;, # ファイルパス／URL（拡張子が必要） delim = &quot;;&quot; # 区切り文字（ここでは例としてセミコロンを指定） col_names = TRUE, # ヘッダー（列名データ）の有無／列名指定 col_types = NULL, # 各列の型の指定（c：文字列型、d：数値型、D：日付型、l：論理値型） col_select = NULL, # 読み込む列の指定（列名、インデックス） skip = 0, # 読み込み時に上からスキップする行数 locale = locale(encoding = &quot;CP932&quot;) # Windows標準（Shift JIS）で作成されたファイルは&quot;CP932&quot;、utf-8で作成されたファイルは&quot;UTF-8&quot; ) Excelデータの読み込み（xls／xlsx形式） readrパッケージのread_excel()関数は、Excelのxls形式、xlsx形式どちらも読み込み可能です。ただし、読み込み元としてpath引数に指定できるのはローカルネットワーク内のファイルパスだけで、ウェブのURLからの読み込みはできません。 data &lt;- readxl::read_excel(path = &quot;directory/file.xls&quot;, # ファイルパス（拡張子が必要、URLは不可） sheet = NULL, # シートインデックス／シート名 col_names = TRUE, # ヘッダー（列名データ）の有無／列名指定 col_types = NULL, # 各列の型の指定（c：文字列型、d：数値型、D：日付型、l：論理値型） skip = 0 # 読み込み時に上からスキップする行数 ) Excelデータの読み込み（xlsx形式） openxlsxパッケージのread.xlsx()関数であれば、ローカルネットワーク内のファイルパスとウェブのURLどちらからでも読み込みが可能です。ただし、読み込めるファイル形式はxlsx形式のみで、xls形式には対応していません。 data &lt;- openxlsx::read.xlsx(xlsxFile = &quot;directory/file.xlsx&quot;, # ファイルパス／URL（拡張子が必要） sheet = 1, # シートインデックス／シート名 startRow = 5, # 読み込み開始行 colNames = TRUE, # 列名データの有無 rowNames = FALSE, # 行名データの有無 rows = 5:53, # 読み込む列（NULLですべて読み込み） cols = NULL # 読み込む行（NULLですべて読み込み） ) CSVデータの書き出し CSVデータを書き出す（CSVファイルとして保存する）には、write.csv()関数を使用します。 write.csv(..., # 書き出すオブジェクト名（クオーテーションは不要） file = &quot;directory/file.csv&quot;, # 書き出し先のファイルパス（拡張子が必要） row.names = FALSE # 行番号を付与するか ) 2.13 オブジェクトのセーブ・ロード セーブ RのオブジェクトをRData形式で保存します。 save(..., # セーブするオブジェクト名（クオーテーションは不要） file = &quot;directory/file.RData&quot; # セーブ先のファイルパス（拡張子が必要） ) ロード 保存したRData形式のオブジェクトを読み込みます。 load(file = &quot;directory/file.RData&quot;) # ロード元ファイルパス（拡張子が必要） "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
