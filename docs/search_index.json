[["index.html", "エコノミストのためのRコード はじめに", " エコノミストのためのRコード 服部直樹 2022-05-11 はじめに 経済・金融分析で使用するRのコード集です。 "],["rの設定.html", "1 Rの設定 1.1 設定全般 1.2 プロキシサーバーの設定 1.3 パッケージのインストールとインポート 1.4 グラフの設定", " 1 Rの設定 Rを使用する際の各種設定です。パッケージのインストール・インポートや、プロキシサーバーの設定（プロキシ環境のみ）など、Rの使用に欠かせない様々な設定について記載しています。 1.1 設定全般 Rのバージョン確認 Rのバージョン情報を出力します。 version ## _ ## platform x86_64-w64-mingw32 ## arch x86_64 ## os mingw32 ## system x86_64, mingw32 ## status ## major 4 ## minor 1.3 ## year 2022 ## month 03 ## day 10 ## svn rev 81868 ## language R ## version.string R version 4.1.3 (2022-03-10) ## nickname One Push-Up セッション情報の確認 Rのバージョンに加え、使用環境、パッケージ情報を出力します。 sessionInfo() ## R version 4.1.3 (2022-03-10) ## Platform: x86_64-w64-mingw32/x64 (64-bit) ## Running under: Windows 10 x64 (build 19044) ## ## Matrix products: default ## ## locale: ## [1] LC_COLLATE=Japanese_Japan.932 LC_CTYPE=Japanese_Japan.932 ## [3] LC_MONETARY=Japanese_Japan.932 LC_NUMERIC=C ## [5] LC_TIME=Japanese_Japan.932 ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## loaded via a namespace (and not attached): ## [1] bookdown_0.26 digest_0.6.29 R6_2.5.1 jsonlite_1.8.0 ## [5] magrittr_2.0.3 evaluate_0.15 stringi_1.7.6 rlang_1.0.2 ## [9] cli_3.2.0 rstudioapi_0.13 jquerylib_0.1.4 bslib_0.3.1 ## [13] rmarkdown_2.13 tools_4.1.3 stringr_1.4.0 xfun_0.30 ## [17] yaml_2.3.5 fastmap_1.1.0 compiler_4.1.3 htmltools_0.5.2 ## [21] knitr_1.38 sass_0.4.1 警告の非表示 Rが出力する警告（Warning）を非表示にします。 options(warn = -1) 関数が出力する警告やメッセージの非表示 関数が出力する警告やメッセージはoptions(warn = -1)で非表示にできないため、suppressWarnings()関数やsuppressMessages()関数を使用します。 suppressWarnings(警告を出力する関数) suppressMessages(メッセージを出力する関数) 1.2 プロキシサーバーの設定 Webからデータを直接読み込むため、企業や大学などのプロキシ環境ではプロキシサーバーの設定を行ってください。なお、下記のコードは認証プロキシには非対応です。 ## プロキシサーバーとポートを記入 proxy_url &lt;- &quot;http://proxyserver:port/&quot; ## Rのシステム環境変数を設定 Sys.setenv(&quot;http_proxy&quot; = proxy_url) Sys.setenv(&quot;https_proxy&quot; = proxy_url) ## Rのダウンロードオプションを設定 options(download.file.method = &quot;libcurl&quot;) options(timeout = NA) 1.3 パッケージのインストールとインポート 使用するパッケージ一覧 tidyverse系 lubridate：日付処理 magrittr：パイプ処理 tidyverse：モダンなデータ分析用パッケージセット readxl：Excelファイルの読み込み 図表系 esquisse：shanyを使用した直感的な図表作成 geofacet：地図形式のファセット図配置 ggplotgui：shanyを使用した直感的な図表作成 ggpubr：論文形式の図表作成 ggsci：科学系論文の雑誌別カラーパレット ggrepel：散布図のラベル付与 lemon：ファセット図の軸・目盛り表示 RColorBrewer：カラーパレット 統計系 mgcv：一般化加法モデル（GAM） plm：パネルデータモデル sigmoid：シグモイド関数 tidyquant：金融時系列データ分析 その他 openxlsx：Excelのxlsxファイルの読み込み・編集・書き出し パッケージのインストールとインポート パッケージのインストールはinstall.packages()関数、インストールしたパッケージのインポート（呼び出し）はlibrary()関数で実行します。一度インストールすれば、その後はインポートするだけでパッケージを使用することができます。 # パッケージ一覧 packages &lt;- c( &quot;lubridate&quot;, &quot;magrittr&quot;, &quot;tidyverse&quot;, &quot;readxl&quot;, &quot;esquisse&quot;, &quot;geofacet&quot;, &quot;ggplotgui&quot;, &quot;ggpubr&quot;, &quot;ggsci&quot;, &quot;ggrepel&quot;, &quot;lemon&quot;, &quot;RColorBrewer&quot;, &quot;mgcv&quot;, &quot;plm&quot;, &quot;sigmoid&quot;, &quot;tidyquant&quot;, &quot;openxlsx&quot; ) # インストールしていないパッケージがあればインストール new_packages &lt;- packages[!(packages %in% installed.packages()[,&quot;Package&quot;])] if(length(new_packages)) { install.packages(new_packages) } # パッケージをインポート for (pkg in packages) { library(pkg, character.only = TRUE) } # 変数を削除 rm( new_packages, packages, pkg ) Rのパッケージは開発者が随時アップデートしていますが、自動で反映されることはありません。パッケージをアップデートする場合は、次のコードを実行してください。 # パッケージをすべてアップデート update.packages() # アップデートの対象になる古いバージョンのパッケージ一覧を出力 old.packages() # パッケージを指定してアップデート install.packages(&quot;tidyverse&quot;) 1.4 グラフの設定 レポートやスライドに掲載するためのグラフは、主にRのggplot2パッケージで作成します。 グラフのテーマ設定 実務上、Excelと併用することを想定しているため、Excelで出力されるグラフに似たテーマを設定します。ggplot2にデフォルトで用意されている様々なテーマについては、公式ウェブサイトを参照してください。 theme_set(theme_light()) グラフのフォント設定 Windows上でRを使用する場合は、日本語フォントをグラフ上で表示するために以下の設定が必要です。ここでは代表的なフォントとしてMeiryo UIとYu Gothic UIを設定します。それぞれのフォントにMEIRYO、YUGOというキーを割り当て、ggplot2でグラフを作成する際にキーを指定します。 windowsFonts(&quot;MEIRYO&quot; = windowsFont(&quot;Meiryo UI&quot;)) windowsFonts(&quot;YUGO&quot; = windowsFont(&quot;Yu Gothic UI&quot;)) "],["rの基本的な使用方法.html", "2 Rの基本的な使用方法 2.1 主要ショートカットキー 2.2 基本操作 2.3 演算 2.4 ベクトル 2.5 行列 2.6 データフレーム 2.7 リスト 2.8 制御構文 2.9 データの読み込み・書き出し 2.10 オブジェクトのセーブ・ロード", " 2 Rの基本的な使用方法 本節では、Rの基本的な使用方法について解説します。本節の内容は基礎部分のみのため、詳細は、馬場真哉（2020）『R言語ではじめるプログラミングとデータ分析』や、Hadley Wickham、Garrett Grolemund（2017）『Rではじめるデータサイエンス』などを参照してください。 RStudioでコードを編集するパネルをソース（Source）と呼びます。RStudioの左上のパネルがソースで、コンソール（Console）パネルの上にあります。ソースが表示されていない場合は、FileメニューからNew Fileに進み、R Scriptを選択すると、ソースが表示されます。 ソースにコードを記述し、記述したコードの行にカーソルがある状態でCtrl + Enterを押すと、コンソールに実行結果が表示されます。 2.1 主要ショートカットキー Alt + Shift + K：キーボードショートカットを表示 編集 Ctrl + S：保存 Ctrl + A：すべて選択 Ctrl + Shift + R：セクション区切りを挿入 Ctrl + Shift + C：選択範囲をコメントアウト／コメントアウト解除 Ctrl + Shift + M：パイプオペレータ%&gt;%を挿入 実行 Ctrl + Enter：カーソルがある行／選択している部分のコードを実行 Ctrl + Alt + T：カーソルがあるセクションのコードをすべて実行 Ctrl + Alt + R：すべてのコードを実行 その他 F1：カーソルがある関数のヘルプを表示 2.2 基本操作 # 代入は &lt;- か = x &lt;- 2 x ## [1] 2 # シャープでコメントアウト（実行されない） 2.3 演算 四則計算 # 足し算 1 + 1 ## [1] 2 # 引き算 3 - 1 ## [1] 2 # 掛け算 2 * 3 ## [1] 6 # 割り算 10 / 5 ## [1] 2 # 割り算の整数の商 10 %/% 3 ## [1] 3 # 割り算の余り 10 %% 3 ## [1] 1 # べき乗 3 ** 2 ## [1] 9 3 ^ 2 ## [1] 9 数値計算 # 自然対数 log(10) ## [1] 2.302585 # ネイピア数のべき乗 exp(1) ## [1] 2.718282 # 平方根 sqrt(2) ## [1] 1.414214 # 絶対値 abs(-5) ## [1] 5 一致・大小関係 # 一致 2 == 2 ## [1] TRUE # 不一致 3 != 2 ## [1] TRUE # より大きい 3 &gt; 2 ## [1] TRUE # 以上 3 &gt;= 3 ## [1] TRUE # より小さい 2 &lt; 3 ## [1] TRUE # 以下 2 &lt;= 2 ## [1] TRUE 包含関係・集合関係 # 包含関係 1:5 %in% c(1, 2, 5) ## [1] TRUE TRUE FALSE FALSE TRUE # 和集合 union(seq(0, 20, 2), seq(0, 20, 3)) ## [1] 0 2 4 6 8 10 12 14 16 18 20 3 9 15 # 共通部分 intersect(seq(0, 20, 2), seq(0, 20, 3)) ## [1] 0 6 12 18 # 差分 setdiff(seq(0, 20, 2), seq(0, 20, 3)) ## [1] 2 4 8 10 14 16 20 2.4 ベクトル ベクトルの作成 ベクトルは複数の要素を一つにまとめたデータ構造で、c()関数で作成します。一つのベクトルには単一のデータ型のみ格納でき、数値型や文字列型のデータを混在させることはできません。 # 数値型ベクトルの作成 vec_1 &lt;- c(11, 12, 13, 14, 15) vec_1 ## [1] 11 12 13 14 15 # 文字列型ベクトルの作成 vec_2 &lt;- c(&quot;Hello&quot;, &quot;World&quot;) vec_2 ## [1] &quot;Hello&quot; &quot;World&quot; # 数値型データと文字列型データを混在させると、すべて文字列型に変換される c(1, 2, &quot;A&quot;, &quot;B&quot;) ## [1] &quot;1&quot; &quot;2&quot; &quot;A&quot; &quot;B&quot; ベクトル要素へのアクセス ベクトルでは、ベクトル[要素のインデックス]の形でインデックスを指定して各要素にアクセスすることができます。なお、Pythonなど他のプログラミング言語のインデックスは0から始まりますが、Rのインデックスは1から始まる点に注意してください。 # ベクトルの要素へのアクセス vec_1[1] ## [1] 11 vec_1[5] ## [1] 15 vec_1[2:4] ## [1] 12 13 14 rev(vec_1)[1] ## [1] 15 規則性があるベクトルの作成 規則性があるベクトルを作成するには、コロン（:）、seq()関数、rep()関数を使用します。 # 1から10までの等差数列 1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 # 0から20までの2つ置きの数列 seq(from = 0, to = 20, by = 2) ## [1] 0 2 4 6 8 10 12 14 16 18 20 # 1から10までを4等分する等差数列 seq(from = 1, to = 10, length.out = 4) ## [1] 1 4 7 10 # 要素の繰り返し rep(x = 2, times = 5) ## [1] 2 2 2 2 2 # ベクトルの繰り返し rep(x = c(1, 2), times = 3) ## [1] 1 2 1 2 1 2 # ベクトルの各要素の繰り返し rep(x = c(1, 2), each = 3) ## [1] 1 1 1 2 2 2 ベクトルの演算 ベクトルの演算を行うと、ベクトルの対応する要素どうしが計算され、ベクトルが出力されます。ベクトルの長さが異なる場合は、短い方のベクトルが使いまわされて長さを合わせます。 *演算子はベクトルの要素どうしの掛け算を行う点に注意してください。ベクトルの内積を計算するには%*%演算子を使用します。 vec_3 &lt;- c(1, 2, 3) vec_4 &lt;- c(5, 6, 7) # ベクトル要素の足し算 vec_3 + vec_4 ## [1] 6 8 10 # ベクトル要素の引き算 vec_3 - vec_4 ## [1] -4 -4 -4 # ベクトル要素の掛け算 vec_3 * vec_4 ## [1] 5 12 21 # ベクトル要素の割り算 vec_3 / vec_4 ## [1] 0.2000000 0.3333333 0.4285714 # ベクトルの内積 vec_3 %*% vec_4 ## [,1] ## [1,] 38 2.5 行列 行列の作成 行列はmatrix()関数を使用し、ベクトルを複数の列・行に分割する形で作成します。 # ベクトルを複数列に分割して行列を作成 mat_1 &lt;- matrix( data = 1:10, ncol = 2 ) mat_1 ## [,1] [,2] ## [1,] 1 6 ## [2,] 2 7 ## [3,] 3 8 ## [4,] 4 9 ## [5,] 5 10 # ベクトルを複数行に分割して行列を作成 mat_2 &lt;- matrix( data = 1:10, nrow = 2 ) mat_2 ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 3 5 7 9 ## [2,] 2 4 6 8 10 行列の要素へのアクセス 行列の要素にアクセスするには、ベクトルと同様に行列[要素の行インデックス, 要素の列インデックス]の形でインデックスを指定します。 # 行列の3行目・1列目の要素を取得 mat_1[3, 1] ## [1] 3 # 行列の4行目全体を取得 mat_1[4, ] ## [1] 4 9 # 行列の2列目全体を取得 mat_1[, 2] ## [1] 6 7 8 9 10 # 行列の1～3行目を取得 mat_1[1:3, ] ## [,1] [,2] ## [1,] 1 6 ## [2,] 2 7 ## [3,] 3 8 # 行列の1～3行目以外を取得 mat_1[-1:-3, ] ## [,1] [,2] ## [1,] 4 9 ## [2,] 5 10 行列の演算 行列の演算を行うと、行列の対応する要素どうしが計算され、行列が出力されます。 *演算子は行列の要素どうしの掛け算を行う点に注意してください。行列の積を計算するには%*%演算子を使用します。 mat_2 &lt;- matrix( data = 1:4, ncol = 2 ) mat_3 &lt;- matrix( data = 5:8, ncol = 2 ) # 行列要素の足し算 mat_2 + mat_3 ## [,1] [,2] ## [1,] 6 10 ## [2,] 8 12 # 行列要素の引き算 mat_2 - mat_3 ## [,1] [,2] ## [1,] -4 -4 ## [2,] -4 -4 # 行列要素の掛け算 mat_2 * mat_3 ## [,1] [,2] ## [1,] 5 21 ## [2,] 12 32 # 行列要素の割り算 mat_2 / mat_3 ## [,1] [,2] ## [1,] 0.2000000 0.4285714 ## [2,] 0.3333333 0.5000000 # 各行の和 rowSums(mat_2) ## [1] 4 6 # 各列の和 colSums(mat_2) ## [1] 3 7 # 行列の積 mat_2 %*% mat_3 ## [,1] [,2] ## [1,] 23 31 ## [2,] 34 46 # 行列の転置 t(mat_2) ## [,1] [,2] ## [1,] 1 2 ## [2,] 3 4 # 逆行列 solve(mat_2) ## [,1] [,2] ## [1,] -2 1.5 ## [2,] 1 -0.5 2.6 データフレーム データフレームは、同じ長さの列ベクトルを複数まとめた行列形式のデータ構造で、Rによる分析を行う上で最も頻繁に使用します。Excelのスプレッドシートのイメージに近く、実際にCSV形式のファイルをRに読み込むとデータフレーム形式のオブジェクトが作成されます。 なお、データフレームには、Rにもともと備わっているdata.frame形式と、tidyverseパッケージによって導入されたtibble形式の2種類があります。両者にはいくつか違いがありますが、data.frame形式を使いやすくしたものがtibble形式と言えます。詳細はtibbleパッケージの公式ウェブサイトを参照してください。 データフレームの作成 tibble形式のデータフレームは、tibble()関数を使用して列名 = 要素の形で作成します。データフレームではすべての列ベクトルの要素数が同じになるようにします。 df_1 &lt;- tibble( x = 1:5, y = 6:10, z = x ^ 2 + y ) df_1 ## # A tibble: 5 x 3 ## x y z ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1 6 7 ## 2 2 7 11 ## 3 3 8 17 ## 4 4 9 25 ## 5 5 10 35 データフレームの要素へのアクセス データフレームでは、データフレーム$列名の形で各列ベクトルにアクセスすることができます。また、データフレーム$列名[要素インデックス]で各列ベクトルの要素にアクセスできます。 df_1$x ## [1] 1 2 3 4 5 df_1$z[3] ## [1] 17 また、角括弧を使用して要素にアクセスすることもできます。ここで、一重の角括弧と二重の角括弧では実行結果が異なる点に注意してください。一重角括弧では、結果がtibble形式で出力されます。一方、二重角括弧ではベクトルや単一の数値といった要素そのものが出力されます。 df_1[&quot;x&quot;] ## # A tibble: 5 x 1 ## x ## &lt;int&gt; ## 1 1 ## 2 2 ## 3 3 ## 4 4 ## 5 5 df_1[1] ## # A tibble: 5 x 1 ## x ## &lt;int&gt; ## 1 1 ## 2 2 ## 3 3 ## 4 4 ## 5 5 df_1[2, 2] ## # A tibble: 1 x 1 ## y ## &lt;int&gt; ## 1 7 df_1[[&quot;x&quot;]] ## [1] 1 2 3 4 5 df_1[[1]] ## [1] 1 2 3 4 5 df_1[[2, 2]] ## [1] 7 その他のデータフレームの機能 df_2 &lt;- tibble( letters = LETTERS, numbers = 1:26 ) df_2 ## # A tibble: 26 x 2 ## letters numbers ## &lt;chr&gt; &lt;int&gt; ## 1 A 1 ## 2 B 2 ## 3 C 3 ## 4 D 4 ## 5 E 5 ## 6 F 6 ## 7 G 7 ## 8 H 8 ## 9 I 9 ## 10 J 10 ## # ... with 16 more rows # データフレームの上部のみ表示 head(df_2) ## # A tibble: 6 x 2 ## letters numbers ## &lt;chr&gt; &lt;int&gt; ## 1 A 1 ## 2 B 2 ## 3 C 3 ## 4 D 4 ## 5 E 5 ## 6 F 6 # データフレームの下部のみ表示 tail(df_2) ## # A tibble: 6 x 2 ## letters numbers ## &lt;chr&gt; &lt;int&gt; ## 1 U 21 ## 2 V 22 ## 3 W 23 ## 4 X 24 ## 5 Y 25 ## 6 Z 26 # データフレームの列名一覧を出力 colnames(df_2) ## [1] &quot;letters&quot; &quot;numbers&quot; 2.7 リスト リストは、単一の数値、文字列、ベクトル、データフレームなど、様々な種類のデータを格納することができる容器のようなものです。リストそのものをリストに格納することもできます。リストはlist()関数で作成します。リストに格納する各要素には、それぞれ名前を付けることができます。 リストの作成 list_1 &lt;- list( number = 1, string = &quot;a&quot;, vector = c(10, 11, 12), matrix = matrix(1:9, ncol = 3) ) list_1 ## $number ## [1] 1 ## ## $string ## [1] &quot;a&quot; ## ## $vector ## [1] 10 11 12 ## ## $matrix ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 リストの要素へのアクセス リストでは、データフレームと同様にリスト$要素名の形でドルマークを使用して各要素にアクセスすることができます。 list_1$number ## [1] 1 list_1$matrix ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 また、ベクトルや行列と同様に、リスト[[要素インデックス]]でも各要素にアクセスすることができます。ここで、角括弧が二重である点に注意してください。 list_1[[3]] ## [1] 10 11 12 2.8 制御構文 制御構文には、条件分岐を行うifやelse、同じ操作の繰り返しを行うforやwhile、エラー処理を行うtryがあります。 if/else文 if文は、if (条件) {処理}の形で記述します。else ifで追加条件、elseで「その他すべて」の場合を意味します。 x &lt;- 5 if (x &lt; 2) { print(&quot;A&quot;) } else if (x &gt;= 2 &amp; x &lt; 6) { print(&quot;B&quot;) } else { print(&quot;C&quot;) } ## [1] &quot;B&quot; forループ for文は、for (変数 in 変数に逐次代入する要素) {処理}の形で記述します。変数はカウンタではない点に注意してください。 for (i in 1:5) { print(i) } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 for (letter in letters[1:6]) { print(letter) } ## [1] &quot;a&quot; ## [1] &quot;b&quot; ## [1] &quot;c&quot; ## [1] &quot;d&quot; ## [1] &quot;e&quot; ## [1] &quot;f&quot; 変数をカウンタとして使用する場合は、seq_along()関数をfor (変数 in seq_along(変数に逐次代入する要素を格納したベクトル等))の形で用いると、自動的に要素数に応じたインデックスを変数に代入してくれます。 for (i in seq_along(letters[1:6])) { print(str_c(i, &quot;_&quot;, letters[1:6][i])) } ## [1] &quot;1_a&quot; ## [1] &quot;2_b&quot; ## [1] &quot;3_c&quot; ## [1] &quot;4_d&quot; ## [1] &quot;5_e&quot; ## [1] &quot;6_f&quot; whileループ while文は、while (繰り返し処理を続ける条件) {処理}の形で記述します。「繰り返し処理を続ける条件」が有限回数で終わるように処理内容を工夫します。例えば、下記のように条件を「カウンタが正の値」にしておき、処理の中でカウンタが減少するように書くのが一般的です。 count &lt;- 3 while (count &gt; 0) { print(count) count &lt;- count - 1 } ## [1] 3 ## [1] 2 ## [1] 1 breakによる繰り返しの終了 while文の処理の中でbreak文を用い、ループを強制的に終了させることができます。 vec_break &lt;- c(10, 20, 30, 40, 50) index &lt;- 1 while(TRUE) { # indexがvec_breakの要素数を超えると繰り返しを終了 if (index &gt; length(vec_break)) { break } print(vec_break[index]) index &lt;- index + 1 } ## [1] 10 ## [1] 20 ## [1] 30 ## [1] 40 ## [1] 50 tryによるエラー処理 エラーを起こす可能性がある処理をtry()関数のexpr = {}内に記述することで、エラーが発生しても処理を続けることができます。 list_try &lt;- list(1, 2, 3, &quot;4&quot;, 5) for (i in seq_along(list_try)) { try( expr = { # エラーの可能性がある処理 x &lt;- log(list_try[[i]]) print(x) }, silent = FALSE # TRUEにするとエラーの内容を非表示 ) } ## [1] 0 ## [1] 0.6931472 ## [1] 1.098612 ## Error in log(list_try[[i]]) : 数学関数に数値でない引数が渡されました ## [1] 1.609438 2.9 データの読み込み・書き出し CSVデータの読み込み data &lt;- readr::read_csv(file = &quot;directory/file.csv&quot;, # ファイルパス／URL（拡張子が必要） col_names = TRUE, # ヘッダー（列名データ）の有無 col_types = NULL, # 各列の型の指定（c：文字列型、d：数値型、D：日付型、l：論理値型） skip = 0) # 読み込み時に上からスキップする行数 Excelデータの読み込み（xls形式） readrパッケージのread_excel()関数はExcelのxls形式、xlsx形式どちらも読み込み可能です。ただし、読み込みができるのはローカルネットワーク内のファイルパスだけで、URLからの読み込みはできません。 data &lt;- readxl::read_excel(path = &quot;directory/file.xls&quot;, # ファイルパス（拡張子が必要、URLは不可） sheet = NULL, # シートインデックス／シート名 col_names = TRUE, # ヘッダー（列名データ）の有無 col_types = NULL, # 各列の型の指定（c：文字列型、d：数値型、D：日付型、l：論理値型） skip = 0) # 読み込み時に上からスキップする行数 Excelデータの読み込み（xlsx形式） openxlsxパッケージのread.xlsx()関数であれば、ローカルネットワーク内のファイルパスとURLどちらからでも読み込みが可能です。ただし、読み込めるファイル形式はxlsx形式のみで、xls形式には対応していません。 data &lt;- openxlsx::read.xlsx(xlsxFile = &quot;directory/file.xlsx&quot;, # ファイルパス／URL（拡張子が必要） sheet = 1, # シートインデックス／シート名 startRow = 5, # 読み込み開始行 colNames = TRUE, # 列名データの有無 rowNames = FALSE, # 行名データの有無 rows = 5:53, # 読み込む列（NULLですべて読み込み） cols = NULL) # 読み込む行（NULLですべて読み込み） CSVデータの書き出し write.csv(..., # 書き出すオブジェクト名（クオーテーションは不要） file = &quot;directory/file.csv&quot;, # 書き出し先のファイルパス（拡張子が必要） row.names = FALSE) # 行番号を付与するか 2.10 オブジェクトのセーブ・ロード セーブ RのオブジェクトをRData形式で保存します。 save(..., # セーブするオブジェクト名（クオーテーションは不要） file = &quot;directory/file.RData&quot;) # セーブ先のファイルパス（拡張子が必要） ロード 保存したRData形式のオブジェクトを呼び出します。 load(file = &quot;directory/file.RData&quot;) # ロード元ファイルパス（拡張子が必要） "],["tidyverseによるデータ操作.html", "3 tidyverseによるデータ操作 3.1 パッケージのインポート 3.2 tidyverseとは 3.3 サンプルデータの読み込み 3.4 列の選択 3.5 列名の変更 3.6 行のフィルタ 3.7 行の並べ替え 3.8 列の追加・修正 3.9 グループ化 3.10 集計 3.11 縦型・横型の変換 3.12 データの結合 3.13 重複処理 3.14 欠損値処理 3.15 補完処理 3.16 時系列データの頻度変換", " 3 tidyverseによるデータ操作 本節では、tidyverseのdplyrパッケージとtidyrパッケージを使用した効率的なデータ操作のコードについて解説します。 3.1 パッケージのインポート library(magrittr) library(tidyverse) library(tidyquant) 3.2 tidyverseとは tidyverseは、Rでデータを効率的に操作・可視化するために開発された様々なパッケージをひとまとめにしたものです。本節では、データ操作に関わるdplyrパッケージとtidyrパッケージを主に使用します。 dplyr：データセットに様々な操作を加えるパッケージ tidyr：データセットをtidy dataに変形するためのパッケージ tidy dataとは、tidyverseの開発者であるHadley Wickham氏が提唱した概念で、機械処理しやすいデータ形式のことを言います。その要件は次の通りです。 1つの列が1つの変数を表す 1つの行が1つのレコードを表す 1つのテーブルが1つのデータセットだけを含む 例えば、国別・産業別GDPの時系列データであれば、国の列、産業の列、時点の列、データ（GDP）の列、の4列で構成されるデータがtidy dataです。こうしたデータを縦型データとも呼びます。これに対して、国や産業が横方向に並んでいる場合（日本・製造業のGDPの列、日本・飲食業のGDPの列、米国・金融業のGDPの列…など）は、tidy data（縦型データ）ではなく、横型データと呼ばれます。tidy dataは属性条件によるフィルタがかけやすいなど、データ処理が列方向に一括して行えるため、機械処理に適しています。 tidy dataの詳細については、松村優哉、湯谷啓明、紀ノ定保礼、前田和寛（2021）『改訂2版 Rユーザのための RStudio［実践］入門』を参照してください。 dplyrパッケージやtidyrパッケージの関数は、もとのデータセットに対して変更を一切加えません。データセットを操作した結果を残しておくためには、結果をオブジェクトに代入する必要があります。なお、代入先をもとのデータセットのオブジェクトにすると、データセットの内容が書き換えられます。 tidyverseではパイプ%&gt;%が多用されます。パイプは、データセットに対して適用した関数の結果を、次の関数へと受け渡すものです。パイプを連続して使用することで、処理の途中の結果をいちいちオブジェクトに代入することなく、一括して複数の処理を行うことができます。以下はmpgデータセットに対する複数の関数の処理をパイプでつなげたものです。 # mpgデータセットからmanufacturer列とcty列を選択し、manufacturer列でフィルタしたうえで、 # cty列を10倍し、結果をresultオブジェクトに保存する例 result &lt;- mpg %&gt;% dplyr::select(manufacturer, cty) %&gt;% dplyr::filter(manufacturer == &quot;toyota&quot;) %&gt;% dplyr::mutate(cty_10 = cty * 10) print(result) ## # A tibble: 34 x 3 ## manufacturer cty cty_10 ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 toyota 15 150 ## 2 toyota 16 160 ## 3 toyota 15 150 ## 4 toyota 15 150 ## 5 toyota 16 160 ## 6 toyota 14 140 ## 7 toyota 21 210 ## 8 toyota 21 210 ## 9 toyota 21 210 ## 10 toyota 21 210 ## # ... with 24 more rows 3.3 サンプルデータの読み込み 本節で使用するサンプルデータをWebから直接読み込みます。プロキシ環境では、プロキシサーバーの設定が必要です。 ## プロキシサーバーとポートを記入 proxy_url &lt;- &quot;http://proxyserver:port/&quot; ## Rのシステム環境変数を設定 Sys.setenv(&quot;http_proxy&quot; = proxy_url) Sys.setenv(&quot;https_proxy&quot; = proxy_url) ## Rのダウンロードオプションを設定 options(download.file.method = &quot;libcurl&quot;) options(timeout = NA) ここでは、Our World in Dataの新型コロナウイルス関連データセットを使用します。データの詳細はこちらを参照してください。 Hannah Ritchie, Edouard Mathieu, Lucas Rodés-Guirao, Cameron Appel, Charlie Giattino, Esteban Ortiz-Ospina, Joe Hasell, Bobbie Macdonald, Diana Beltekian and Max Roser (2020) - “Coronavirus Pandemic (COVID-19)”. Published online at OurWorldInData.org. Retrieved from: ‘https://ourworldindata.org/coronavirus’ [Online Resource] # Our World in Dataの新型コロナデータをtibble型で読み込み data_owid &lt;- readr::read_csv(file = &quot;https://covid.ourworldindata.org/data/owid-covid-data.csv&quot;, # ファイルパス／URL col_names = TRUE, # ヘッダー（列名データ）の有無 col_types = NULL, # 各列の型の指定（c：文字列型、d：数値型、D：日付型、l：論理値型） skip = 0) # 読み込み時に上からスキップする行数 # 使用するデータを絞り込み data_owid %&lt;&gt;% dplyr::select(continent, location, date, total_cases, new_cases, total_deaths, new_deaths, total_cases_per_million, new_cases_per_million, total_deaths_per_million, new_deaths_per_million, people_fully_vaccinated) %&gt;% dplyr::filter(location %in% c(&quot;Japan&quot;, &quot;United States&quot;, &quot;United Kingdom&quot;, &quot;Germany&quot;)) # データをコンソールに出力 data_owid ## # A tibble: 3,342 x 12 ## continent location date total_cases new_cases total_deaths new_deaths ## &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Europe Germany 2020-01-27 1 1 NA NA ## 2 Europe Germany 2020-01-28 4 3 NA NA ## 3 Europe Germany 2020-01-29 4 0 NA NA ## 4 Europe Germany 2020-01-30 4 0 NA NA ## 5 Europe Germany 2020-01-31 5 1 NA NA ## 6 Europe Germany 2020-02-01 8 3 NA NA ## 7 Europe Germany 2020-02-02 10 2 NA NA ## 8 Europe Germany 2020-02-03 12 2 NA NA ## 9 Europe Germany 2020-02-04 12 0 NA NA ## 10 Europe Germany 2020-02-05 12 0 NA NA ## # ... with 3,332 more rows, and 5 more variables: ## # total_cases_per_million &lt;dbl&gt;, new_cases_per_million &lt;dbl&gt;, ## # total_deaths_per_million &lt;dbl&gt;, new_deaths_per_million &lt;dbl&gt;, ## # people_fully_vaccinated &lt;dbl&gt; 3.4 列の選択 データセットから列（変数）を選択するには、dplyr::select()関数を使用します。 列名で選択 data_owid %&gt;% dplyr::select(location, date, new_cases) ## # A tibble: 3,342 x 3 ## location date new_cases ## &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; ## 1 Germany 2020-01-27 1 ## 2 Germany 2020-01-28 3 ## 3 Germany 2020-01-29 0 ## 4 Germany 2020-01-30 0 ## 5 Germany 2020-01-31 1 ## 6 Germany 2020-02-01 3 ## 7 Germany 2020-02-02 2 ## 8 Germany 2020-02-03 2 ## 9 Germany 2020-02-04 0 ## 10 Germany 2020-02-05 0 ## # ... with 3,332 more rows 列名を格納したベクトルで選択 cols &lt;- c(&quot;location&quot;, &quot;date&quot;, &quot;new_cases&quot;) data_owid %&gt;% dplyr::select(cols) ## Note: Using an external vector in selections is ambiguous. ## i Use `all_of(cols)` instead of `cols` to silence this message. ## i See &lt;https://tidyselect.r-lib.org/reference/faq-external-vector.html&gt;. ## This message is displayed once per session. ## # A tibble: 3,342 x 3 ## location date new_cases ## &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; ## 1 Germany 2020-01-27 1 ## 2 Germany 2020-01-28 3 ## 3 Germany 2020-01-29 0 ## 4 Germany 2020-01-30 0 ## 5 Germany 2020-01-31 1 ## 6 Germany 2020-02-01 3 ## 7 Germany 2020-02-02 2 ## 8 Germany 2020-02-03 2 ## 9 Germany 2020-02-04 0 ## 10 Germany 2020-02-05 0 ## # ... with 3,332 more rows 列を非選択（削除） data_owid %&gt;% dplyr::select(-location) ## # A tibble: 3,342 x 11 ## continent date total_cases new_cases total_deaths new_deaths ## &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Europe 2020-01-27 1 1 NA NA ## 2 Europe 2020-01-28 4 3 NA NA ## 3 Europe 2020-01-29 4 0 NA NA ## 4 Europe 2020-01-30 4 0 NA NA ## 5 Europe 2020-01-31 5 1 NA NA ## 6 Europe 2020-02-01 8 3 NA NA ## 7 Europe 2020-02-02 10 2 NA NA ## 8 Europe 2020-02-03 12 2 NA NA ## 9 Europe 2020-02-04 12 0 NA NA ## 10 Europe 2020-02-05 12 0 NA NA ## # ... with 3,332 more rows, and 5 more variables: ## # total_cases_per_million &lt;dbl&gt;, new_cases_per_million &lt;dbl&gt;, ## # total_deaths_per_million &lt;dbl&gt;, new_deaths_per_million &lt;dbl&gt;, ## # people_fully_vaccinated &lt;dbl&gt; 列名に特定の文字列を含む列を選択 data_owid %&gt;% dplyr::select(location, date, contains(&quot;cases&quot;)) ## # A tibble: 3,342 x 6 ## location date total_cases new_cases total_cases_per_m~ new_cases_per_m~ ## &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Germany 2020-01-27 1 1 0.012 0.012 ## 2 Germany 2020-01-28 4 3 0.048 0.036 ## 3 Germany 2020-01-29 4 0 0.048 0 ## 4 Germany 2020-01-30 4 0 0.048 0 ## 5 Germany 2020-01-31 5 1 0.06 0.012 ## 6 Germany 2020-02-01 8 3 0.095 0.036 ## 7 Germany 2020-02-02 10 2 0.119 0.024 ## 8 Germany 2020-02-03 12 2 0.143 0.024 ## 9 Germany 2020-02-04 12 0 0.143 0 ## 10 Germany 2020-02-05 12 0 0.143 0 ## # ... with 3,332 more rows 列名が特定の文字列から始まる列を選択 data_owid %&gt;% dplyr::select(location, date, starts_with(&quot;new_cases&quot;)) ## # A tibble: 3,342 x 4 ## location date new_cases new_cases_per_million ## &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Germany 2020-01-27 1 0.012 ## 2 Germany 2020-01-28 3 0.036 ## 3 Germany 2020-01-29 0 0 ## 4 Germany 2020-01-30 0 0 ## 5 Germany 2020-01-31 1 0.012 ## 6 Germany 2020-02-01 3 0.036 ## 7 Germany 2020-02-02 2 0.024 ## 8 Germany 2020-02-03 2 0.024 ## 9 Germany 2020-02-04 0 0 ## 10 Germany 2020-02-05 0 0 ## # ... with 3,332 more rows 列名が特定の文字列で終わる列を選択 data_owid %&gt;% dplyr::select(location, date, ends_with(c(&quot;cases&quot;, &quot;deaths&quot;))) ## # A tibble: 3,342 x 6 ## location date total_cases new_cases total_deaths new_deaths ## &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Germany 2020-01-27 1 1 NA NA ## 2 Germany 2020-01-28 4 3 NA NA ## 3 Germany 2020-01-29 4 0 NA NA ## 4 Germany 2020-01-30 4 0 NA NA ## 5 Germany 2020-01-31 5 1 NA NA ## 6 Germany 2020-02-01 8 3 NA NA ## 7 Germany 2020-02-02 10 2 NA NA ## 8 Germany 2020-02-03 12 2 NA NA ## 9 Germany 2020-02-04 12 0 NA NA ## 10 Germany 2020-02-05 12 0 NA NA ## # ... with 3,332 more rows 特定の型の列を選択 data_owid %&gt;% dplyr::select(where(is.character) | where(is.Date)) ## # A tibble: 3,342 x 3 ## continent location date ## &lt;chr&gt; &lt;chr&gt; &lt;date&gt; ## 1 Europe Germany 2020-01-27 ## 2 Europe Germany 2020-01-28 ## 3 Europe Germany 2020-01-29 ## 4 Europe Germany 2020-01-30 ## 5 Europe Germany 2020-01-31 ## 6 Europe Germany 2020-02-01 ## 7 Europe Germany 2020-02-02 ## 8 Europe Germany 2020-02-03 ## 9 Europe Germany 2020-02-04 ## 10 Europe Germany 2020-02-05 ## # ... with 3,332 more rows 3.5 列名の変更 データセットの列名（変数名）を変更するときは、dplyr::rename()関数を使用します。 data_owid %&gt;% dplyr::rename(country = location) ## # A tibble: 3,342 x 12 ## continent country date total_cases new_cases total_deaths new_deaths ## &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Europe Germany 2020-01-27 1 1 NA NA ## 2 Europe Germany 2020-01-28 4 3 NA NA ## 3 Europe Germany 2020-01-29 4 0 NA NA ## 4 Europe Germany 2020-01-30 4 0 NA NA ## 5 Europe Germany 2020-01-31 5 1 NA NA ## 6 Europe Germany 2020-02-01 8 3 NA NA ## 7 Europe Germany 2020-02-02 10 2 NA NA ## 8 Europe Germany 2020-02-03 12 2 NA NA ## 9 Europe Germany 2020-02-04 12 0 NA NA ## 10 Europe Germany 2020-02-05 12 0 NA NA ## # ... with 3,332 more rows, and 5 more variables: ## # total_cases_per_million &lt;dbl&gt;, new_cases_per_million &lt;dbl&gt;, ## # total_deaths_per_million &lt;dbl&gt;, new_deaths_per_million &lt;dbl&gt;, ## # people_fully_vaccinated &lt;dbl&gt; 3.6 行のフィルタ データセットの行のフィルタ（特定の条件を満たすデータの抽出）を行うには、dpoyr::filter()関数を使用します。 条件に一致する行 data_owid %&gt;% dplyr::filter(location == &quot;Japan&quot;) ## # A tibble: 839 x 12 ## continent location date total_cases new_cases total_deaths new_deaths ## &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Asia Japan 2020-01-22 2 NA NA NA ## 2 Asia Japan 2020-01-23 2 0 NA NA ## 3 Asia Japan 2020-01-24 2 0 NA NA ## 4 Asia Japan 2020-01-25 2 0 NA NA ## 5 Asia Japan 2020-01-26 4 2 NA NA ## 6 Asia Japan 2020-01-27 4 0 NA NA ## 7 Asia Japan 2020-01-28 7 3 NA NA ## 8 Asia Japan 2020-01-29 7 0 NA NA ## 9 Asia Japan 2020-01-30 11 4 NA NA ## 10 Asia Japan 2020-01-31 15 4 NA NA ## # ... with 829 more rows, and 5 more variables: total_cases_per_million &lt;dbl&gt;, ## # new_cases_per_million &lt;dbl&gt;, total_deaths_per_million &lt;dbl&gt;, ## # new_deaths_per_million &lt;dbl&gt;, people_fully_vaccinated &lt;dbl&gt; 条件に一致しない行（NOT条件） NOT条件は!=演算子を使用します。 data_owid %&gt;% dplyr::filter(continent != &quot;Asia&quot;) ## # A tibble: 2,503 x 12 ## continent location date total_cases new_cases total_deaths new_deaths ## &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Europe Germany 2020-01-27 1 1 NA NA ## 2 Europe Germany 2020-01-28 4 3 NA NA ## 3 Europe Germany 2020-01-29 4 0 NA NA ## 4 Europe Germany 2020-01-30 4 0 NA NA ## 5 Europe Germany 2020-01-31 5 1 NA NA ## 6 Europe Germany 2020-02-01 8 3 NA NA ## 7 Europe Germany 2020-02-02 10 2 NA NA ## 8 Europe Germany 2020-02-03 12 2 NA NA ## 9 Europe Germany 2020-02-04 12 0 NA NA ## 10 Europe Germany 2020-02-05 12 0 NA NA ## # ... with 2,493 more rows, and 5 more variables: ## # total_cases_per_million &lt;dbl&gt;, new_cases_per_million &lt;dbl&gt;, ## # total_deaths_per_million &lt;dbl&gt;, new_deaths_per_million &lt;dbl&gt;, ## # people_fully_vaccinated &lt;dbl&gt; 複数条件 dplyr::filter()関数内で複数条件を指定すると、左から順番に条件が適用されます。 data_owid %&gt;% dplyr::filter(location == &quot;Japan&quot;, date &gt;= &quot;2021-01-01&quot;, date &lt;= &quot;2021-01-07&quot;) ## # A tibble: 7 x 12 ## continent location date total_cases new_cases total_deaths new_deaths ## &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Asia Japan 2021-01-01 239005 3256 3541 49 ## 2 Asia Japan 2021-01-02 242076 3071 3572 31 ## 3 Asia Japan 2021-01-03 245242 3166 3632 60 ## 4 Asia Japan 2021-01-04 248585 3343 3680 48 ## 5 Asia Japan 2021-01-05 253534 4949 3756 76 ## 6 Asia Japan 2021-01-06 259583 6049 3821 65 ## 7 Asia Japan 2021-01-07 267225 7642 3885 64 ## # ... with 5 more variables: total_cases_per_million &lt;dbl&gt;, ## # new_cases_per_million &lt;dbl&gt;, total_deaths_per_million &lt;dbl&gt;, ## # new_deaths_per_million &lt;dbl&gt;, people_fully_vaccinated &lt;dbl&gt; AND・OR条件を明示的に指定した複数条件 左から順番に条件を適用しないためには、&amp;演算子と|演算子で明示的にAND条件とOR条件を指定します。 data_owid %&gt;% dplyr::filter((date == &quot;2022-01-01&quot;) &amp; (location == &quot;Japan&quot; | location == &quot;United States&quot;)) ## # A tibble: 2 x 12 ## continent location date total_cases new_cases total_deaths new_deaths ## &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Asia Japan 2022-01-01 1732752 456 18389 0 ## 2 North Ameri~ United ~ 2022-01-01 55024055 188724 824696 392 ## # ... with 5 more variables: total_cases_per_million &lt;dbl&gt;, ## # new_cases_per_million &lt;dbl&gt;, total_deaths_per_million &lt;dbl&gt;, ## # new_deaths_per_million &lt;dbl&gt;, people_fully_vaccinated &lt;dbl&gt; %in%演算子によるOR条件 複数の値が格納されたベクトルと%in%演算子を用いて、OR条件で行をフィルタします。この場合は、日本と米国のレコードを抽出しています。 locations &lt;- c(&quot;Japan&quot;, &quot;United States&quot;) data_owid %&gt;% dplyr::filter(location %in% locations, date == &quot;2021-01-01&quot;) ## # A tibble: 2 x 12 ## continent location date total_cases new_cases total_deaths new_deaths ## &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Asia Japan 2021-01-01 239005 3256 3541 49 ## 2 North Ameri~ United ~ 2021-01-01 20370208 178902 352185 2247 ## # ... with 5 more variables: total_cases_per_million &lt;dbl&gt;, ## # new_cases_per_million &lt;dbl&gt;, total_deaths_per_million &lt;dbl&gt;, ## # new_deaths_per_million &lt;dbl&gt;, people_fully_vaccinated &lt;dbl&gt; OR条件の否定 %in%演算子によるOR条件を!で否定します。この場合は、日本・米国以外を抽出しています。 data_owid %&gt;% dplyr::filter(!location %in% locations, date == &quot;2021-01-01&quot;) ## # A tibble: 2 x 12 ## continent location date total_cases new_cases total_deaths new_deaths ## &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Europe Germany 2021-01-01 1742661 22924 33624 553 ## 2 Europe United Kin~ 2021-01-01 2545102 53312 74183 614 ## # ... with 5 more variables: total_cases_per_million &lt;dbl&gt;, ## # new_cases_per_million &lt;dbl&gt;, total_deaths_per_million &lt;dbl&gt;, ## # new_deaths_per_million &lt;dbl&gt;, people_fully_vaccinated &lt;dbl&gt; 関数による条件指定 data_owid %&gt;% dplyr::filter(date == max(date)) ## # A tibble: 4 x 12 ## continent location date total_cases new_cases total_deaths new_deaths ## &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Europe Germany 2022-05-09 25406868 107568 136756 218 ## 2 Asia Japan 2022-05-09 8126472 28353 29847 33 ## 3 Europe United ~ 2022-05-09 22215152 26253 176596 212 ## 4 North Ameri~ United ~ 2022-05-09 81973661 110182 998040 514 ## # ... with 5 more variables: total_cases_per_million &lt;dbl&gt;, ## # new_cases_per_million &lt;dbl&gt;, total_deaths_per_million &lt;dbl&gt;, ## # new_deaths_per_million &lt;dbl&gt;, people_fully_vaccinated &lt;dbl&gt; 論理値を返す関数による条件指定 is.na()関数のように倫理値を返す関数は、==演算子がなくてもフィルタ条件として使用することができます。 data_owid %&gt;% dplyr::filter(is.na(new_cases)) ## # A tibble: 6 x 12 ## continent location date total_cases new_cases total_deaths new_deaths ## &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Europe Germany 2022-04-01 21357039 NA 129695 NA ## 2 Asia Japan 2020-01-22 2 NA NA NA ## 3 Europe United ~ 2021-04-09 4369510 NA 127126 60 ## 4 Europe United ~ 2021-05-18 4454449 NA 127777 7 ## 5 Europe United ~ 2022-01-31 17357576 NA 155884 56 ## 6 North Ameri~ United ~ 2020-01-22 1 NA NA NA ## # ... with 5 more variables: total_cases_per_million &lt;dbl&gt;, ## # new_cases_per_million &lt;dbl&gt;, total_deaths_per_million &lt;dbl&gt;, ## # new_deaths_per_million &lt;dbl&gt;, people_fully_vaccinated &lt;dbl&gt; 3.7 行の並べ替え データセットの行を並べ替えるには、dplyr::arrange()関数を使用します。 昇順ソート data_owid %&gt;% dplyr::arrange(new_cases) ## # A tibble: 3,342 x 12 ## continent location date total_cases new_cases total_deaths new_deaths ## &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Europe Germany 2020-01-29 4 0 NA NA ## 2 Europe Germany 2020-01-30 4 0 NA NA ## 3 Europe Germany 2020-02-04 12 0 NA NA ## 4 Europe Germany 2020-02-05 12 0 NA NA ## 5 Europe Germany 2020-02-06 12 0 NA NA ## 6 Europe Germany 2020-02-08 13 0 NA NA ## 7 Europe Germany 2020-02-10 14 0 NA NA ## 8 Europe Germany 2020-02-12 16 0 NA NA ## 9 Europe Germany 2020-02-13 16 0 NA NA ## 10 Europe Germany 2020-02-14 16 0 NA NA ## # ... with 3,332 more rows, and 5 more variables: ## # total_cases_per_million &lt;dbl&gt;, new_cases_per_million &lt;dbl&gt;, ## # total_deaths_per_million &lt;dbl&gt;, new_deaths_per_million &lt;dbl&gt;, ## # people_fully_vaccinated &lt;dbl&gt; 降順ソート data_owid %&gt;% dplyr::arrange(-new_cases) ## # A tibble: 3,342 x 12 ## continent location date total_cases new_cases total_deaths new_deaths ## &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 North Amer~ United ~ 2022-01-10 61800974 1383896 839275 2014 ## 2 North Amer~ United ~ 2022-01-18 67871065 1129512 855231 2684 ## 3 North Amer~ United ~ 2022-01-03 56354902 1044929 826921 1844 ## 4 North Amer~ United ~ 2022-01-24 71942831 922059 868764 2164 ## 5 North Amer~ United ~ 2022-01-19 68779154 908089 858669 3438 ## 6 North Amer~ United ~ 2022-01-14 65178388 880062 849807 2738 ## 7 North Amer~ United ~ 2022-01-07 59534381 869727 835855 2396 ## 8 North Amer~ United ~ 2022-01-13 64298326 861348 847069 2517 ## 9 North Amer~ United ~ 2022-01-12 63436978 848616 844552 2808 ## 10 North Amer~ United ~ 2022-01-21 70352839 841074 864925 3359 ## # ... with 3,332 more rows, and 5 more variables: ## # total_cases_per_million &lt;dbl&gt;, new_cases_per_million &lt;dbl&gt;, ## # total_deaths_per_million &lt;dbl&gt;, new_deaths_per_million &lt;dbl&gt;, ## # people_fully_vaccinated &lt;dbl&gt; 降順ソート（日付型） 日付型のデータは-演算子で降順ソートができないため、desc()関数を使用します。 data_owid %&gt;% dplyr::arrange(desc(date)) ## # A tibble: 3,342 x 12 ## continent location date total_cases new_cases total_deaths new_deaths ## &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Europe Germany 2022-05-09 25406868 107568 136756 218 ## 2 Asia Japan 2022-05-09 8126472 28353 29847 33 ## 3 Europe United ~ 2022-05-09 22215152 26253 176596 212 ## 4 North Amer~ United ~ 2022-05-09 81973661 110182 998040 514 ## 5 Europe Germany 2022-05-08 25299300 3350 136538 5 ## 6 Asia Japan 2022-05-08 8098119 42406 29814 26 ## 7 Europe United ~ 2022-05-08 22188899 0 176384 0 ## 8 North Amer~ United ~ 2022-05-08 81863479 4981 997526 23 ## 9 Europe Germany 2022-05-07 25295950 8488 136533 10 ## 10 Asia Japan 2022-05-07 8055713 39228 29788 27 ## # ... with 3,332 more rows, and 5 more variables: ## # total_cases_per_million &lt;dbl&gt;, new_cases_per_million &lt;dbl&gt;, ## # total_deaths_per_million &lt;dbl&gt;, new_deaths_per_million &lt;dbl&gt;, ## # people_fully_vaccinated &lt;dbl&gt; 複数条件によるソート dplyr::arrange()関数内で複数条件を指定すると、左から順番に適用します。 data_owid %&gt;% dplyr::arrange(desc(date), -new_cases) ## # A tibble: 3,342 x 12 ## continent location date total_cases new_cases total_deaths new_deaths ## &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 North Amer~ United ~ 2022-05-09 81973661 110182 998040 514 ## 2 Europe Germany 2022-05-09 25406868 107568 136756 218 ## 3 Asia Japan 2022-05-09 8126472 28353 29847 33 ## 4 Europe United ~ 2022-05-09 22215152 26253 176596 212 ## 5 Asia Japan 2022-05-08 8098119 42406 29814 26 ## 6 North Amer~ United ~ 2022-05-08 81863479 4981 997526 23 ## 7 Europe Germany 2022-05-08 25299300 3350 136538 5 ## 8 Europe United ~ 2022-05-08 22188899 0 176384 0 ## 9 Asia Japan 2022-05-07 8055713 39228 29788 27 ## 10 North Amer~ United ~ 2022-05-07 81858498 26890 997503 185 ## # ... with 3,332 more rows, and 5 more variables: ## # total_cases_per_million &lt;dbl&gt;, new_cases_per_million &lt;dbl&gt;, ## # total_deaths_per_million &lt;dbl&gt;, new_deaths_per_million &lt;dbl&gt;, ## # people_fully_vaccinated &lt;dbl&gt; 3.8 列の追加・修正 データセットの列を追加・修正するには、dplyr::mutate()関数を使用します。 まず、使用するサンプルデータを作成します。 data_owid_jp &lt;- data_owid %&gt;% dplyr::select(location, date, new_cases, new_deaths) %&gt;% dplyr::filter(location == &quot;Japan&quot;, date &gt;= &quot;2022-01-01&quot;) 新たな列の作成 既存の列（変数）の計算結果として、新たな列を追加します。=演算子の左側が新たに作成する列名、右側が計算式です。作成する際、.before引数もしくは.after引数に既存の列名を指定すると、指定した列の前後に新たな列を挿入します。.before引数、.after引数を指定しなければ、新たな列は最右列に追加されます。 data_owid_jp %&gt;% dplyr::mutate(death_rate = new_deaths / new_cases, .after = &quot;date&quot;) ## # A tibble: 129 x 5 ## location date death_rate new_cases new_deaths ## &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Japan 2022-01-01 0 456 0 ## 2 Japan 2022-01-02 0.00419 477 2 ## 3 Japan 2022-01-03 0.00149 672 1 ## 4 Japan 2022-01-04 0.000870 1149 1 ## 5 Japan 2022-01-05 0.000402 2490 1 ## 6 Japan 2022-01-06 0.000233 4297 1 ## 7 Japan 2022-01-07 0.000165 6070 1 ## 8 Japan 2022-01-08 0.000241 8302 2 ## 9 Japan 2022-01-09 0.000124 8071 1 ## 10 Japan 2022-01-10 0.000319 6265 2 ## # ... with 119 more rows 既存の列の修正 =演算子の左側に既存の列名を指定すると、当該列を修正します。 data_owid %&gt;% dplyr::mutate(location = factor(location)) ## # A tibble: 3,342 x 12 ## continent location date total_cases new_cases total_deaths new_deaths ## &lt;chr&gt; &lt;fct&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Europe Germany 2020-01-27 1 1 NA NA ## 2 Europe Germany 2020-01-28 4 3 NA NA ## 3 Europe Germany 2020-01-29 4 0 NA NA ## 4 Europe Germany 2020-01-30 4 0 NA NA ## 5 Europe Germany 2020-01-31 5 1 NA NA ## 6 Europe Germany 2020-02-01 8 3 NA NA ## 7 Europe Germany 2020-02-02 10 2 NA NA ## 8 Europe Germany 2020-02-03 12 2 NA NA ## 9 Europe Germany 2020-02-04 12 0 NA NA ## 10 Europe Germany 2020-02-05 12 0 NA NA ## # ... with 3,332 more rows, and 5 more variables: ## # total_cases_per_million &lt;dbl&gt;, new_cases_per_million &lt;dbl&gt;, ## # total_deaths_per_million &lt;dbl&gt;, new_deaths_per_million &lt;dbl&gt;, ## # people_fully_vaccinated &lt;dbl&gt; ラグ・リード系列の作成 dplyr::lag()関数とdplyr::leag()関数で、既存の列のラグ・リード系列を作成します。 # 1期ラグの系列を追加 data_owid_jp %&gt;% dplyr::mutate(new_cases_lag = dplyr::lag(new_cases, n = 1)) ## # A tibble: 129 x 5 ## location date new_cases new_deaths new_cases_lag ## &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Japan 2022-01-01 456 0 NA ## 2 Japan 2022-01-02 477 2 456 ## 3 Japan 2022-01-03 672 1 477 ## 4 Japan 2022-01-04 1149 1 672 ## 5 Japan 2022-01-05 2490 1 1149 ## 6 Japan 2022-01-06 4297 1 2490 ## 7 Japan 2022-01-07 6070 1 4297 ## 8 Japan 2022-01-08 8302 2 6070 ## 9 Japan 2022-01-09 8071 1 8302 ## 10 Japan 2022-01-10 6265 2 8071 ## # ... with 119 more rows 変化率系列の作成 dplyr::lag()関数で、既存の列の変化率系列を作成します。 # 前期比変化率（％表示）の系列を追加 data_owid_jp %&gt;% dplyr::mutate(new_cases_chg = 100 * (new_cases / dplyr::lag(new_cases, n = 1) - 1)) ## # A tibble: 129 x 5 ## location date new_cases new_deaths new_cases_chg ## &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Japan 2022-01-01 456 0 NA ## 2 Japan 2022-01-02 477 2 4.61 ## 3 Japan 2022-01-03 672 1 40.9 ## 4 Japan 2022-01-04 1149 1 71.0 ## 5 Japan 2022-01-05 2490 1 117. ## 6 Japan 2022-01-06 4297 1 72.6 ## 7 Japan 2022-01-07 6070 1 41.3 ## 8 Japan 2022-01-08 8302 2 36.8 ## 9 Japan 2022-01-09 8071 1 -2.78 ## 10 Japan 2022-01-10 6265 2 -22.4 ## # ... with 119 more rows 移動平均系列の作成 zoo::rollmean()関数で、移動平均系列を作成します。 # 後方7日移動平均の系列を追加 data_owid_jp %&gt;% dplyr::mutate(new_cases_7dma = zoo::rollmean(new_cases, # 移動平均を作成するもとの系列名 k = 7, # 移動平均の期間 na.pad = TRUE, # 系列の先端部分で移動平均を計算できない箇所をNAで埋めるか align = &quot;right&quot;)) # left：前方移動平均、center：中央移動平均、right：後方移動平均 ## # A tibble: 129 x 5 ## location date new_cases new_deaths new_cases_7dma ## &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Japan 2022-01-01 456 0 NA ## 2 Japan 2022-01-02 477 2 NA ## 3 Japan 2022-01-03 672 1 NA ## 4 Japan 2022-01-04 1149 1 NA ## 5 Japan 2022-01-05 2490 1 NA ## 6 Japan 2022-01-06 4297 1 NA ## 7 Japan 2022-01-07 6070 1 2230. ## 8 Japan 2022-01-08 8302 2 3351 ## 9 Japan 2022-01-09 8071 1 4436. ## 10 Japan 2022-01-10 6265 2 5235. ## # ... with 119 more rows 条件付き系列の作成 dplyr::case_when()関数の中に、既存の系列を用いた条件 ~ 条件を満たす場合にとる値の形で条件式を書き、新たな系列を作成します。複数条件を指定した場合、左から順番に条件が適用されます。「その他すべて」の条件はTRUEで指定します。 # 単一条件を指定してダミー変数を作成 data_owid_jp %&gt;% dplyr::mutate(dummy = dplyr::case_when(new_cases &lt; 3000 ~ 1, TRUE ~ 0)) ## # A tibble: 129 x 5 ## location date new_cases new_deaths dummy ## &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Japan 2022-01-01 456 0 1 ## 2 Japan 2022-01-02 477 2 1 ## 3 Japan 2022-01-03 672 1 1 ## 4 Japan 2022-01-04 1149 1 1 ## 5 Japan 2022-01-05 2490 1 1 ## 6 Japan 2022-01-06 4297 1 0 ## 7 Japan 2022-01-07 6070 1 0 ## 8 Japan 2022-01-08 8302 2 0 ## 9 Japan 2022-01-09 8071 1 0 ## 10 Japan 2022-01-10 6265 2 0 ## # ... with 119 more rows # 複数条件を指定 data_owid_jp %&gt;% dplyr::mutate(case = dplyr::case_when(new_cases &lt; 1000 ~ &quot;A&quot;, (new_cases &gt;= 5000 &amp; new_cases &lt; 8000) ~ &quot;B&quot;, TRUE ~ &quot;other&quot;)) ## # A tibble: 129 x 5 ## location date new_cases new_deaths case ## &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Japan 2022-01-01 456 0 A ## 2 Japan 2022-01-02 477 2 A ## 3 Japan 2022-01-03 672 1 A ## 4 Japan 2022-01-04 1149 1 other ## 5 Japan 2022-01-05 2490 1 other ## 6 Japan 2022-01-06 4297 1 other ## 7 Japan 2022-01-07 6070 1 B ## 8 Japan 2022-01-08 8302 2 other ## 9 Japan 2022-01-09 8071 1 other ## 10 Japan 2022-01-10 6265 2 B ## # ... with 119 more rows 複数列の一括処理 dplyr::mutate()関数内でacross()関数を用い、対象の列と処理方法を指定して一括処理します。~ {}は無名関数（ラムダ式）を表し、波括弧の中のドットはチルダの左側の値を代入することを意味します。 # new_casesからnew_deathまでのすべての列を1000で除す data_owid_jp %&gt;% dplyr::mutate(across(new_cases:new_deaths, ~ {. / 1000})) ## # A tibble: 129 x 4 ## location date new_cases new_deaths ## &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Japan 2022-01-01 0.456 0 ## 2 Japan 2022-01-02 0.477 0.002 ## 3 Japan 2022-01-03 0.672 0.001 ## 4 Japan 2022-01-04 1.15 0.001 ## 5 Japan 2022-01-05 2.49 0.001 ## 6 Japan 2022-01-06 4.30 0.001 ## 7 Japan 2022-01-07 6.07 0.001 ## 8 Japan 2022-01-08 8.30 0.002 ## 9 Japan 2022-01-09 8.07 0.001 ## 10 Japan 2022-01-10 6.26 0.002 ## # ... with 119 more rows # new_casesからnew_deathまでのすべての列の前期比変化率を計算 data_owid_jp %&gt;% dplyr::mutate(across(new_cases:new_deaths, ~ {. / dplyr::lag(., n = 1)})) ## # A tibble: 129 x 4 ## location date new_cases new_deaths ## &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Japan 2022-01-01 NA NA ## 2 Japan 2022-01-02 1.05 Inf ## 3 Japan 2022-01-03 1.41 0.5 ## 4 Japan 2022-01-04 1.71 1 ## 5 Japan 2022-01-05 2.17 1 ## 6 Japan 2022-01-06 1.73 1 ## 7 Japan 2022-01-07 1.41 1 ## 8 Japan 2022-01-08 1.37 2 ## 9 Japan 2022-01-09 0.972 0.5 ## 10 Japan 2022-01-10 0.776 2 ## # ... with 119 more rows 3.9 グループ化 データセットを属性ごとにグループ化するには、dplyr::group_by()関数を使用します。グループ化するだけでは変化はありませんが、dplyr::filter()関数や、次のdplyr::summarise()関数とあわせて使用することで、より柔軟なデータセット操作が可能になります。 単一の列でグループ化 見た目は変わりませんが、データをprint()関数で出力するとデータの属性を示す冒頭箇所の2行目にGroupsが追加されています。 data_owid %&gt;% dplyr::group_by(location) %&gt;% print() ## # A tibble: 3,342 x 12 ## # Groups: location [4] ## continent location date total_cases new_cases total_deaths new_deaths ## &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Europe Germany 2020-01-27 1 1 NA NA ## 2 Europe Germany 2020-01-28 4 3 NA NA ## 3 Europe Germany 2020-01-29 4 0 NA NA ## 4 Europe Germany 2020-01-30 4 0 NA NA ## 5 Europe Germany 2020-01-31 5 1 NA NA ## 6 Europe Germany 2020-02-01 8 3 NA NA ## 7 Europe Germany 2020-02-02 10 2 NA NA ## 8 Europe Germany 2020-02-03 12 2 NA NA ## 9 Europe Germany 2020-02-04 12 0 NA NA ## 10 Europe Germany 2020-02-05 12 0 NA NA ## # ... with 3,332 more rows, and 5 more variables: ## # total_cases_per_million &lt;dbl&gt;, new_cases_per_million &lt;dbl&gt;, ## # total_deaths_per_million &lt;dbl&gt;, new_deaths_per_million &lt;dbl&gt;, ## # people_fully_vaccinated &lt;dbl&gt; 複数の列でグループ化 data_owid %&gt;% dplyr::group_by(continent, location) %&gt;% print() ## # A tibble: 3,342 x 12 ## # Groups: continent, location [4] ## continent location date total_cases new_cases total_deaths new_deaths ## &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Europe Germany 2020-01-27 1 1 NA NA ## 2 Europe Germany 2020-01-28 4 3 NA NA ## 3 Europe Germany 2020-01-29 4 0 NA NA ## 4 Europe Germany 2020-01-30 4 0 NA NA ## 5 Europe Germany 2020-01-31 5 1 NA NA ## 6 Europe Germany 2020-02-01 8 3 NA NA ## 7 Europe Germany 2020-02-02 10 2 NA NA ## 8 Europe Germany 2020-02-03 12 2 NA NA ## 9 Europe Germany 2020-02-04 12 0 NA NA ## 10 Europe Germany 2020-02-05 12 0 NA NA ## # ... with 3,332 more rows, and 5 more variables: ## # total_cases_per_million &lt;dbl&gt;, new_cases_per_million &lt;dbl&gt;, ## # total_deaths_per_million &lt;dbl&gt;, new_deaths_per_million &lt;dbl&gt;, ## # people_fully_vaccinated &lt;dbl&gt; グループ化＆フィルタ グループ化と行のフィルタを組み合わせて、グループ別にフィルタを適用します。ここでは、グループ別の最大値を抽出しています。 data_owid %&gt;% dplyr::group_by(location) %&gt;% dplyr::filter(new_cases == max(new_cases, na.rm = TRUE)) ## # A tibble: 4 x 12 ## # Groups: location [4] ## continent location date total_cases new_cases total_deaths new_deaths ## &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Europe Germany 2022-03-31 21357095 527487 129708 596 ## 2 Asia Japan 2022-02-03 3019169 104345 19054 90 ## 3 Europe United ~ 2022-03-21 20380278 225992 163826 168 ## 4 North Ameri~ United ~ 2022-01-10 61800974 1383896 839275 2014 ## # ... with 5 more variables: total_cases_per_million &lt;dbl&gt;, ## # new_cases_per_million &lt;dbl&gt;, total_deaths_per_million &lt;dbl&gt;, ## # new_deaths_per_million &lt;dbl&gt;, people_fully_vaccinated &lt;dbl&gt; グループ化の解除 dplyr::ungroup()関数でグループ化を解除します。グループ化の有無でフィルタや集計の結果が変わるため、思わぬ事故を防ぐためにも、所定の結果を得た後はグループ化を解除しておくことを推奨します。 data_owid %&gt;% dplyr::group_by(location) %&gt;% dplyr::ungroup() ## # A tibble: 3,342 x 12 ## continent location date total_cases new_cases total_deaths new_deaths ## &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Europe Germany 2020-01-27 1 1 NA NA ## 2 Europe Germany 2020-01-28 4 3 NA NA ## 3 Europe Germany 2020-01-29 4 0 NA NA ## 4 Europe Germany 2020-01-30 4 0 NA NA ## 5 Europe Germany 2020-01-31 5 1 NA NA ## 6 Europe Germany 2020-02-01 8 3 NA NA ## 7 Europe Germany 2020-02-02 10 2 NA NA ## 8 Europe Germany 2020-02-03 12 2 NA NA ## 9 Europe Germany 2020-02-04 12 0 NA NA ## 10 Europe Germany 2020-02-05 12 0 NA NA ## # ... with 3,332 more rows, and 5 more variables: ## # total_cases_per_million &lt;dbl&gt;, new_cases_per_million &lt;dbl&gt;, ## # total_deaths_per_million &lt;dbl&gt;, new_deaths_per_million &lt;dbl&gt;, ## # people_fully_vaccinated &lt;dbl&gt; 3.10 集計 グループ化したデータセットに対してdplyr::summarise()関数を使用すると、グループ別に集計操作を行うことができます。 グループ別の集計 # 指定した列のグループ別の平均値を計算 data_owid %&gt;% dplyr::group_by(location) %&gt;% dplyr::summarise(new_cases_mean = mean(new_cases, na.rm = TRUE)) ## # A tibble: 4 x 2 ## location new_cases_mean ## &lt;chr&gt; &lt;dbl&gt; ## 1 Germany 30501. ## 2 Japan 9697. ## 3 United Kingdom 25846. ## 4 United States 97821. # 指定した列のグループ別の最大値を計算 data_owid %&gt;% dplyr::group_by(location) %&gt;% dplyr::summarise(new_cases_max = max(new_cases, na.rm = TRUE)) ## # A tibble: 4 x 2 ## location new_cases_max ## &lt;chr&gt; &lt;dbl&gt; ## 1 Germany 527487 ## 2 Japan 104345 ## 3 United Kingdom 225992 ## 4 United States 1383896 クロス集計 dplyr::group_by()関数で複数条件を指定してグループ化すると、クロス集計を行うことができます。 data_owid %&gt;% dplyr::group_by(location, lubridate::year(date)) %&gt;% dplyr::summarise(new_cases_mean = mean(new_cases, na.rm = TRUE)) ## `summarise()` has grouped output by &#39;location&#39;. You can override using the ## `.groups` argument. ## # A tibble: 12 x 3 ## # Groups: location [4] ## location `lubridate::year(date)` new_cases_mean ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Germany 2020 5058. ## 2 Germany 2021 14879. ## 3 Germany 2022 142629. ## 4 Japan 2020 685. ## 5 Japan 2021 4100. ## 6 Japan 2022 49567. ## 7 United Kingdom 2020 7416. ## 8 United Kingdom 2021 28871. ## 9 United Kingdom 2022 65647. ## 10 United States 2020 58696. ## 11 United States 2021 94915. ## 12 United States 2022 210375. 複数列の一括処理 dplyr::summarise()関数内でacross()関数を用い、対象の列と処理方法を指定して一括処理します。 # new_casesとnew_deathsの列について、グループ別の合計値を計算 data_owid %&gt;% dplyr::group_by(location) %&gt;% dplyr::summarise(across(c(new_cases, new_deaths), sum, na.rm = TRUE)) ## # A tibble: 4 x 3 ## location new_cases new_deaths ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Germany 25406924 136777 ## 2 Japan 8126470 29847 ## 3 United Kingdom 21374693 172528 ## 4 United States 81973660 998040 # 列名がcasesで終わる列すべてについて、グループ別の合計値を計算 # 列名per_millionで終わる列すべてについて、グループ別の平均値を計算 data_owid %&gt;% dplyr::group_by(location) %&gt;% dplyr::summarise(across(ends_with(&quot;cases&quot;), sum, na.rm = TRUE), across(ends_with(&quot;per_million&quot;), mean, na.rm = TRUE)) ## # A tibble: 4 x 7 ## location total_cases new_cases total_cases_per_million new_cases_per_mi~ ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Germany 3572273153 25406924 51052. 364. ## 2 Japan 1031797442 8126470 9756. 76.9 ## 3 United Kingdom 4868483948 21374693 85998. 379. ## 4 United States 24832438504 81973660 88905. 294. ## # ... with 2 more variables: total_deaths_per_million &lt;dbl&gt;, ## # new_deaths_per_million &lt;dbl&gt; # 数値型の列すべてについて、グループ別の平均値を計算 data_owid %&gt;% dplyr::group_by(location) %&gt;% dplyr::summarise(across(is.double, mean, na.rm = TRUE)) ## # A tibble: 4 x 11 ## location date total_cases new_cases total_deaths new_deaths ## &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Germany 2021-03-18 4283301. 30501. 62949. 173. ## 2 Japan 2021-03-16 1229794. 9697. 10144. 36.5 ## 3 United Kingdom 2021-03-20 5865643. 25846. 99653. 218. ## 4 United States 2021-03-16 29597662. 97821. 488029. 1246. ## # ... with 5 more variables: total_cases_per_million &lt;dbl&gt;, ## # new_cases_per_million &lt;dbl&gt;, total_deaths_per_million &lt;dbl&gt;, ## # new_deaths_per_million &lt;dbl&gt;, people_fully_vaccinated &lt;dbl&gt; 3.11 縦型・横型の変換 tidyrパッケージのpivot_longer()関数とpivot_wider()関数を使用して、縦型データ（tidy data）と横型データの変換を行います。縦型データは、ggplot2パッケージによるグラフ作成で多用します。 まず、使用するサンプルデータを作成します。 data_owid_cases &lt;- data_owid %&gt;% dplyr::select(location, date, new_cases) %&gt;% dplyr::filter(date &gt;= &quot;2021-01-01&quot;) %&gt;% dplyr::arrange(date) data_owid_cases ## # A tibble: 1,976 x 3 ## location date new_cases ## &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; ## 1 Germany 2021-01-01 22924 ## 2 Japan 2021-01-01 3256 ## 3 United Kingdom 2021-01-01 53312 ## 4 United States 2021-01-01 178902 ## 5 Germany 2021-01-02 12690 ## 6 Japan 2021-01-02 3071 ## 7 United Kingdom 2021-01-02 57748 ## 8 United States 2021-01-02 272283 ## 9 Germany 2021-01-03 10315 ## 10 Japan 2021-01-03 3166 ## # ... with 1,966 more rows 縦型データを横型データに変換 data_owid_cases_wide &lt;- data_owid_cases %&gt;% tidyr::pivot_wider(id_cols = &quot;date&quot;, names_from = &quot;location&quot;, values_from = &quot;new_cases&quot;) data_owid_cases_wide ## # A tibble: 494 x 5 ## date Germany Japan `United Kingdom` `United States` ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2021-01-01 22924 3256 53312 178902 ## 2 2021-01-02 12690 3071 57748 272283 ## 3 2021-01-03 10315 3166 55011 203398 ## 4 2021-01-04 9847 3343 58801 185506 ## 5 2021-01-05 11897 4949 60944 232863 ## 6 2021-01-06 21237 6049 62350 259764 ## 7 2021-01-07 26391 7642 52645 286241 ## 8 2021-01-08 31849 7957 68070 304066 ## 9 2021-01-09 24694 7854 59951 264740 ## 10 2021-01-10 16946 6108 54951 210844 ## # ... with 484 more rows 横型データを縦型データに変換 data_owid_cases_long &lt;- data_owid_cases_wide %&gt;% tidyr::pivot_longer(cols = -&quot;date&quot;, names_to = &quot;location&quot;, values_to = &quot;new_cases&quot;) data_owid_cases_long ## # A tibble: 1,976 x 3 ## date location new_cases ## &lt;date&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2021-01-01 Germany 22924 ## 2 2021-01-01 Japan 3256 ## 3 2021-01-01 United Kingdom 53312 ## 4 2021-01-01 United States 178902 ## 5 2021-01-02 Germany 12690 ## 6 2021-01-02 Japan 3071 ## 7 2021-01-02 United Kingdom 57748 ## 8 2021-01-02 United States 272283 ## 9 2021-01-03 Germany 10315 ## 10 2021-01-03 Japan 3166 ## # ... with 1,966 more rows 3.12 データの結合 複数のデータセットのオブジェクトを結合して一つのデータセットにするには、dplyrパッケージのjoin()関数ファミリーを使用します。join()関数は、結合方法によって4種類に分かれています。 まず、使用するサンプルデータを確認します。 band_members ## # A tibble: 3 x 2 ## name band ## &lt;chr&gt; &lt;chr&gt; ## 1 Mick Stones ## 2 John Beatles ## 3 Paul Beatles band_instruments ## # A tibble: 3 x 2 ## name plays ## &lt;chr&gt; &lt;chr&gt; ## 1 John guitar ## 2 Paul bass ## 3 Keith guitar 内部結合 dplyr::inner_join()関数は、両方のデータに共通して存在する行のみ結合し、その他の行は削除します。 dplyr::inner_join(band_members, band_instruments, by = &quot;name&quot;) ## # A tibble: 2 x 3 ## name band plays ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 John Beatles guitar ## 2 Paul Beatles bass 左外部結合 dplyr::left_join()関数は、左側のデータに存在する行のみ結合し、その他の行は削除します。 dplyr::left_join(band_members, band_instruments, by = &quot;name&quot;) ## # A tibble: 3 x 3 ## name band plays ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Mick Stones &lt;NA&gt; ## 2 John Beatles guitar ## 3 Paul Beatles bass 右外部結合 dplyr::right_join()関数は、右側のデータに存在する行のみ結合し、その他の行は削除します。 dplyr::right_join(band_members, band_instruments, by = &quot;name&quot;) ## # A tibble: 3 x 3 ## name band plays ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 John Beatles guitar ## 2 Paul Beatles bass ## 3 Keith &lt;NA&gt; guitar 完全外部結合 dplyr::full_join()関数は、両方のデータのすべての行を結合し、行を削除しません。 dplyr::full_join(band_members, band_instruments, by = &quot;name&quot;) ## # A tibble: 4 x 3 ## name band plays ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Mick Stones &lt;NA&gt; ## 2 John Beatles guitar ## 3 Paul Beatles bass ## 4 Keith &lt;NA&gt; guitar 3.13 重複処理 重複している行を削除するには、dplyr::distinct()関数を使用します。 # すべての列を対象にして、重複している行を削除 data_owid %&gt;% dplyr::distinct() ## # A tibble: 3,342 x 12 ## continent location date total_cases new_cases total_deaths new_deaths ## &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Europe Germany 2020-01-27 1 1 NA NA ## 2 Europe Germany 2020-01-28 4 3 NA NA ## 3 Europe Germany 2020-01-29 4 0 NA NA ## 4 Europe Germany 2020-01-30 4 0 NA NA ## 5 Europe Germany 2020-01-31 5 1 NA NA ## 6 Europe Germany 2020-02-01 8 3 NA NA ## 7 Europe Germany 2020-02-02 10 2 NA NA ## 8 Europe Germany 2020-02-03 12 2 NA NA ## 9 Europe Germany 2020-02-04 12 0 NA NA ## 10 Europe Germany 2020-02-05 12 0 NA NA ## # ... with 3,332 more rows, and 5 more variables: ## # total_cases_per_million &lt;dbl&gt;, new_cases_per_million &lt;dbl&gt;, ## # total_deaths_per_million &lt;dbl&gt;, new_deaths_per_million &lt;dbl&gt;, ## # people_fully_vaccinated &lt;dbl&gt; # 指定した列を対象にして、重複している行を削除 data_owid %&gt;% dplyr::distinct(continent, location) ## # A tibble: 4 x 2 ## continent location ## &lt;chr&gt; &lt;chr&gt; ## 1 Europe Germany ## 2 Asia Japan ## 3 Europe United Kingdom ## 4 North America United States 3.14 欠損値処理 欠損値（NA）がある行を削除したり、NAのレコードを他の値で置き換えたりするには、tidyrパッケージのdrop_na()関数、replace_na()関数、fill()関数を使用します。 まず、使用するサンプルデータを作成します。 data_owid_vaccinated &lt;- data_owid %&gt;% dplyr::select(location, date, people_fully_vaccinated) %&gt;% dplyr::filter(location %in% c(&quot;Japan&quot;, &quot;United States&quot;, &quot;United Kingdom&quot;), date &gt;= &quot;2021-01-01&quot;) %&gt;% dplyr::arrange(date) %&gt;% tidyr::pivot_wider(id_cols = &quot;date&quot;, names_from = &quot;location&quot;, values_from = &quot;people_fully_vaccinated&quot;) tail(data_owid_vaccinated) ## # A tibble: 6 x 4 ## date Japan `United Kingdom` `United States` ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2022-05-04 NA 49780389 220085965 ## 2 2022-05-05 101566339 NA 220119791 ## 3 2022-05-06 NA NA 220151435 ## 4 2022-05-07 NA NA 220162653 ## 5 2022-05-08 NA NA 220163884 ## 6 2022-05-09 101665017 NA NA NAの削除 特定の列を対象にして、NAが含まれている行を削除するには、tidyr::drop_na()関数で列名を指定します。 data_owid_vaccinated %&gt;% tidyr::drop_na(Japan) %&gt;% tail() ## # A tibble: 6 x 4 ## date Japan `United Kingdom` `United States` ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2022-04-25 101399919 49705420 219720292 ## 2 2022-04-26 101432143 49713844 219767099 ## 3 2022-04-28 101458832 49731792 219866592 ## 4 2022-05-01 101532326 49762476 219961533 ## 5 2022-05-05 101566339 NA 220119791 ## 6 2022-05-09 101665017 NA NA すべての列を対象にして、NAが含まれている行を削除するには、tidyr::drop_na()関数の中でeverything()関数を使用します。 data_owid_vaccinated %&gt;% tidyr::drop_na(everything()) %&gt;% tail() ## # A tibble: 6 x 4 ## date Japan `United Kingdom` `United States` ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2022-04-21 101259062 49662026 219571093 ## 2 2022-04-24 101354923 49697444 219674292 ## 3 2022-04-25 101399919 49705420 219720292 ## 4 2022-04-26 101432143 49713844 219767099 ## 5 2022-04-28 101458832 49731792 219866592 ## 6 2022-05-01 101532326 49762476 219961533 NAの置換 特定の列のNAを別の値に置き換えるには、tidyr::replace_na()関数で列名と置換する値を指定します。 data_owid_vaccinated %&gt;% dplyr::mutate(Japan = tidyr::replace_na(data = Japan, replace = 0)) %&gt;% tail() ## # A tibble: 6 x 4 ## date Japan `United Kingdom` `United States` ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2022-05-04 0 49780389 220085965 ## 2 2022-05-05 101566339 NA 220119791 ## 3 2022-05-06 0 NA 220151435 ## 4 2022-05-07 0 NA 220162653 ## 5 2022-05-08 0 NA 220163884 ## 6 2022-05-09 101665017 NA NA NAを他の値に置き換える列が複数ある場合は、dplyr::mutate_at()関数で列名を複数指定して一括処理します。 data_owid_vaccinated %&gt;% dplyr::mutate_at(vars(-date), tidyr::replace_na, replace = 0) %&gt;% tail() ## # A tibble: 6 x 4 ## date Japan `United Kingdom` `United States` ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2022-05-04 0 49780389 220085965 ## 2 2022-05-05 101566339 0 220119791 ## 3 2022-05-06 0 0 220151435 ## 4 2022-05-07 0 0 220162653 ## 5 2022-05-08 0 0 220163884 ## 6 2022-05-09 101665017 0 0 NAのフィル 特定の列のNAを同じ列の前後の値でフィルするには、tidyr::fill()関数で列名を指定します。.direction引数が\"down\"なら上の値でフィル、\"up\"なら下の値でフィルします。 data_owid_vaccinated %&gt;% tidyr::fill(Japan, .direction = &quot;down&quot;) %&gt;% tail() ## # A tibble: 6 x 4 ## date Japan `United Kingdom` `United States` ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2022-05-04 101532326 49780389 220085965 ## 2 2022-05-05 101566339 NA 220119791 ## 3 2022-05-06 101566339 NA 220151435 ## 4 2022-05-07 101566339 NA 220162653 ## 5 2022-05-08 101566339 NA 220163884 ## 6 2022-05-09 101665017 NA NA すべての列のNAの値をフィルする場合は、tidyr::fill()関数の中でeverything()関数を使用します。 data_owid_vaccinated %&gt;% tidyr::fill(c(-date, everything()), .direction = &quot;down&quot;) %&gt;% tail() ## # A tibble: 6 x 4 ## date Japan `United Kingdom` `United States` ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2022-05-04 101532326 49780389 220085965 ## 2 2022-05-05 101566339 49780389 220119791 ## 3 2022-05-06 101566339 49780389 220151435 ## 4 2022-05-07 101566339 49780389 220162653 ## 5 2022-05-08 101566339 49780389 220163884 ## 6 2022-05-09 101665017 49780389 220163884 3.15 補完処理 データセットが特定の属性の組み合わせのレコード（行）を欠いている場合や、時系列データで特定の時点のレコード（行）が含まれていない場合は、tidyr::complete()関数で補完することができます。 まず、使用するサンプルデータを作成します。 # サンプルデータ1 data_complete_1 &lt;- tibble( group = c(1:2, 1, 2), item_id = c(1:2, 2, 3), item_name = c(&quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;b&quot;), value1 = c(1, NA, 3, 4), value2 = 4:7 ) data_complete_1 ## # A tibble: 4 x 5 ## group item_id item_name value1 value2 ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; ## 1 1 1 a 1 4 ## 2 2 2 a NA 5 ## 3 1 2 b 3 6 ## 4 2 3 b 4 7 # サンプルデータ2 data_complete_2 &lt;- tibble( date = as.Date(c(&quot;2022-01-01&quot;, &quot;2022-01-03&quot;, &quot;2022-01-04&quot;)), value = c(11, 13, 14) ) data_complete_2 ## # A tibble: 3 x 2 ## date value ## &lt;date&gt; &lt;dbl&gt; ## 1 2022-01-01 11 ## 2 2022-01-03 13 ## 3 2022-01-04 14 組み合わせ候補の補完 tidyr::complete()関数の中で列名を指定し、当該変数のすべての組み合わせ候補を補完します。補完した行の値はNAになります。 data_complete_1 %&gt;% tidyr::complete(group, item_id, item_name) ## # A tibble: 12 x 5 ## group item_id item_name value1 value2 ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; ## 1 1 1 a 1 4 ## 2 1 1 b NA NA ## 3 1 2 a NA NA ## 4 1 2 b 3 6 ## 5 1 3 a NA NA ## 6 1 3 b NA NA ## 7 2 1 a NA NA ## 8 2 1 b NA NA ## 9 2 2 a NA 5 ## 10 2 2 b NA NA ## 11 2 3 a NA NA ## 12 2 3 b 4 7 tidyr::nesting()関数に複数の列名を指定すると、それらの列について実現値のユニークな組み合わせをあらかじめ求め、それと別の列とのすべての組み合わせ候補を補完します。 data_complete_1 %&gt;% tidyr::complete(group, tidyr::nesting(item_id, item_name)) ## # A tibble: 8 x 5 ## group item_id item_name value1 value2 ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; ## 1 1 1 a 1 4 ## 2 1 2 a NA NA ## 3 1 2 b 3 6 ## 4 1 3 b NA NA ## 5 2 1 a NA NA ## 6 2 2 a NA 5 ## 7 2 2 b NA NA ## 8 2 3 b 4 7 時系列データの補完 時系列データの欠損期間を補完するには、full_seq()関数を使用します。 # 日次データの欠損日を補完 data_complete_2 %&gt;% tidyr::complete(date = full_seq(date, period = 1)) ## # A tibble: 4 x 2 ## date value ## &lt;date&gt; &lt;dbl&gt; ## 1 2022-01-01 11 ## 2 2022-01-02 NA ## 3 2022-01-03 13 ## 4 2022-01-04 14 3.16 時系列データの頻度変換 tidyverseと整合性がある金融時系列データ分析用のパッケージであるtidyquantパッケージのtq_transmute()関数を用いて、時系列データの頻度変換（高頻度データから低頻度データへの変換）を行います。なお、tidyquantは頻度変換以外にも様々な分析機能があります。詳しくは公式ウェブサイトを参照してください。 まず、使用するサンプルデータを作成します。tq_transmute()関数にわたす時系列データは、原則として横型データである点に留意してください。 # サンプルデータ（日次） data_owid_cases_wide &lt;- data_owid %&gt;% dplyr::select(location, date, new_cases) %&gt;% dplyr::filter(date &gt;= &quot;2021-01-01&quot;) %&gt;% dplyr::arrange(date) %&gt;% tidyr::pivot_wider(id_cols = &quot;date&quot;, names_from = &quot;location&quot;, values_from = &quot;new_cases&quot;) 日次データを週次データに変換 tidyquant::tq_transmute()関数を使用して日次データを週次データに変換すると、月曜～日曜のデータがFUNに指定した関数で集計され、日曜の日付で記録されます。 data_owid_cases_wide %&gt;% tidyquant::tq_transmute(select = -date, mutate_fun = apply.weekly, FUN = mean, na.rm = TRUE) ## # A tibble: 72 x 5 ## date Germany Japan `United Kingdom` `United States` ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2021-01-03 15310. 3164. 55357 218194. ## 2 2021-01-10 20409. 6272. 59673. 249146. ## 3 2021-01-17 17856. 6007. 46248. 218560. ## 4 2021-01-24 14488. 5039. 35940. 169681. ## 5 2021-01-31 11632. 3468. 24274. 147196. ## 6 2021-02-07 9664. 2229. 18393 118450. ## 7 2021-02-14 7222. 1483. 13214. 91412 ## 8 2021-02-21 7428. 1260. 11067 65758. ## 9 2021-02-28 7968. 1012 8722. 68589. ## 10 2021-03-07 8264. 1037. 5996 59339 ## # ... with 62 more rows なお、日曜～土曜のデータを集計し日曜の日付で記録したい場合は、rollmean()関数を使用して前方7日移動平均を計算し、日曜の値を抽出します。 data_owid_cases_wide %&gt;% dplyr::mutate(across(-date, rollmean, k = 7, na.pad = TRUE, align = &quot;left&quot;)) %&gt;% dplyr::filter(lubridate::wday(date) == 1) ## # A tibble: 71 x 5 ## date Germany Japan `United Kingdom` `United States` ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2021-01-03 19461. 5851. 59682. 248083. ## 2 2021-01-10 18294. 6057 48583 223458. ## 3 2021-01-17 14720. 5292. 37166 174883. ## 4 2021-01-24 11785. 3656. 25545. 151094 ## 5 2021-01-31 10032. 2378. 19145. 121797. ## 6 2021-02-07 7579 1522. 13912. 94429. ## 7 2021-02-14 7205. 1308. 11231. 67621. ## 8 2021-02-21 7938. 1017. 9265. 69089. ## 9 2021-02-28 8233. 1027. 6119. 60790. ## 10 2021-03-07 9482. 1145. 5783. 54313. ## # ... with 61 more rows 日次データを月次データに変換 tidyquant::tq_transmute()関数を使用して日次データを月次データに変換すると、月初～月末のデータがFUNに指定した関数で集計され、月末の日付で記録されます。 data_owid_cases_wide %&gt;% tidyquant::tq_transmute(select = -date, mutate_fun = apply.monthly, FUN = mean, na.rm = TRUE) ## # A tibble: 17 x 5 ## date Germany Japan `United Kingdom` `United States` ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2021-01-31 16020. 5000. 42872. 198280. ## 2 2021-02-28 8070. 1496. 12849. 86052. ## 3 2021-03-31 11824. 1369. 5460. 58561. ## 4 2021-04-30 19091. 3923. 2610. 62965. ## 5 2021-05-31 9662. 4959. 2436. 29816. ## 6 2021-06-30 1567. 1770. 10461. 13345. ## 7 2021-07-31 1323. 4097. 34210. 42710. ## 8 2021-08-31 5603. 18315. 30143. 138155. ## 9 2021-09-30 9488. 7023. 33950. 138110. ## 10 2021-10-31 11937. 557. 40392. 80945. ## 11 2021-11-30 41309. 143. 39195. 84940. ## 12 2021-12-31 42374. 183. 87679. 201654. ## 13 2022-01-31 85971. 32457. 118173. 653674. ## 14 2022-02-28 176056. 80979. 56411. 141268. ## 15 2022-03-31 213290. 49990. 73515. 34052. ## 16 2022-04-30 119060. 43856. 29888. 41270. ## 17 2022-05-09 66343. 28358. 11385. 69469. 日次データを四半期データに変換 tidyquant::tq_transmute()関数を使用して日次データを四半期データに変換すると、期初～期末のデータがFUNに指定した関数で集計され、期末の日付で記録されます。 data_owid_cases_wide %&gt;% tidyquant::tq_transmute(select = -date, mutate_fun = apply.quarterly, FUN = mean, na.rm = TRUE) ## # A tibble: 6 x 5 ## date Germany Japan `United Kingdom` `United States` ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2021-03-31 12102. 2659. 20645. 115239. ## 2 2021-06-30 10102. 3566. 5198. 35314. ## 3 2021-09-30 5428. 9842. 32754. 105980. ## 4 2021-12-31 31771. 296. 55935. 122921. ## 5 2022-03-31 157852. 53592. 83187. 280833. ## 6 2022-05-09 106574. 40279. 25618. 47778. "],["ggplot2によるグラフ作成.html", "4 ggplot2によるグラフ作成 4.1 パッケージのインポート 4.2 ggplot2とは 4.3 ggplot2の設定 4.4 サンプルデータの確認・読み込み 4.5 GUI形式の直感的なグラフ作成 4.6 ヒストグラム 4.7 密度グラフ 4.8 頻度棒グラフ 4.9 頻度バブルチャート 4.10 散布図・バブルチャート 4.11 棒グラフ 4.12 円グラフ 4.13 折れ線グラフ 4.14 ステップグラフ 4.15 面グラフ 4.16 箱ひげグラフ・ヴァイオリングラフ 4.17 ドットプロット 4.18 色の設定 4.19 軸の設定 4.20 複数グラフ（ファセット） 4.21 地図ファセット 4.22 その他設定・保存 4.23 実例", " 4 ggplot2によるグラフ作成 本節では、tidyverseのggplot2パッケージを使用したグラフ作成のコードについて解説します。 4.1 パッケージのインポート library(esquisse) library(geofacet) library(ggplotgui) library(ggpubr) library(ggsci) library(ggrepel) library(lemon) library(magrittr) library(openxlsx) library(RColorBrewer) library(readxl) library(tidyverse) 4.2 ggplot2とは ggplot2パッケージでは、最初にggplot()関数でグラフを作成するデータセットと変数を指定します。その後に、geom_histogram()などのグラフの種類を指定する関数や、scale_x_dateなどの軸設定の関数、theme()などの各種設定の関数を+で追加していきます。 ggplot()関数では、data引数にtibble形式のデータセットを指定します。mapping引数には必ずaes()関数を指定し、aes()関数の中でX軸やY軸の変数、必要に応じてcolorやsizeなど変数の値に応じて変化させる色・サイズなどの要素を指定します。 なお、グラフの種類により、X軸、Y軸に指定できる変数の型（連続型、離散型）が決まっていますので、注意してください。 ggplot2パッケージの詳細については公式ウェブサイトを参照してください。各関数の使い方については、公式ウェブサイトのチートシートが分かりやすくまとまっています。 4.3 ggplot2の設定 ## ggplotのテーマ設定（Excelのグラフと類似したテーマを選択） theme_set(theme_light()) ## Windowsにおけるggplot2の日本語フォント設定 windowsFonts(&quot;MEIRYO&quot; = windowsFont(&quot;Meiryo UI&quot;)) windowsFonts(&quot;YUGO&quot; = windowsFont(&quot;Yu Gothic UI&quot;)) 4.4 サンプルデータの確認・読み込み Rのサンプルデータセット # irisデータセット iris_tbl &lt;- as.tibble(iris) iris_tbl ## # A tibble: 150 x 5 ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa ## 7 4.6 3.4 1.4 0.3 setosa ## 8 5 3.4 1.5 0.2 setosa ## 9 4.4 2.9 1.4 0.2 setosa ## 10 4.9 3.1 1.5 0.1 setosa ## # ... with 140 more rows # mpgデータセット mpg ## # A tibble: 234 x 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto~ f 18 29 p comp~ ## 2 audi a4 1.8 1999 4 manu~ f 21 29 p comp~ ## 3 audi a4 2 2008 4 manu~ f 20 31 p comp~ ## 4 audi a4 2 2008 4 auto~ f 21 30 p comp~ ## 5 audi a4 2.8 1999 6 auto~ f 16 26 p comp~ ## 6 audi a4 2.8 1999 6 manu~ f 18 26 p comp~ ## 7 audi a4 3.1 2008 6 auto~ f 18 27 p comp~ ## 8 audi a4 quattro 1.8 1999 4 manu~ 4 18 26 p comp~ ## 9 audi a4 quattro 1.8 1999 4 auto~ 4 16 25 p comp~ ## 10 audi a4 quattro 2 2008 4 manu~ 4 20 28 p comp~ ## # ... with 224 more rows # economicsデータセット economics ## # A tibble: 574 x 6 ## date pce pop psavert uempmed unemploy ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1967-07-01 507. 198712 12.6 4.5 2944 ## 2 1967-08-01 510. 198911 12.6 4.7 2945 ## 3 1967-09-01 516. 199113 11.9 4.6 2958 ## 4 1967-10-01 512. 199311 12.9 4.9 3143 ## 5 1967-11-01 517. 199498 12.8 4.7 3066 ## 6 1967-12-01 525. 199657 11.8 4.8 3018 ## 7 1968-01-01 531. 199808 11.7 5.1 2878 ## 8 1968-02-01 534. 199920 12.3 4.5 3001 ## 9 1968-03-01 544. 200056 11.7 4.1 2877 ## 10 1968-04-01 544 200208 12.3 4.6 2709 ## # ... with 564 more rows 外部データセット Webからデータを直接読み込むため、プロキシ環境ではプロキシサーバーの設定が必要です。 ## プロキシサーバーとポートを記入 proxy_url &lt;- &quot;http://proxyserver:port/&quot; ## Rのシステム環境変数を設定 Sys.setenv(&quot;http_proxy&quot; = proxy_url) Sys.setenv(&quot;https_proxy&quot; = proxy_url) ## Rのダウンロードオプションを設定 options(download.file.method = &quot;libcurl&quot;) options(timeout = NA) まず、Our World in Dataの新型コロナウイルス関連データを読み込みます。データの詳細はこちらを参照してください。 Hannah Ritchie, Edouard Mathieu, Lucas Rodés-Guirao, Cameron Appel, Charlie Giattino, Esteban Ortiz-Ospina, Joe Hasell, Bobbie Macdonald, Diana Beltekian and Max Roser (2020) - “Coronavirus Pandemic (COVID-19)”. Published online at OurWorldInData.org. Retrieved from: ‘https://ourworldindata.org/coronavirus’ [Online Resource] # Our World in Dataの新型コロナデータをtibble型で読み込み data_owid &lt;- readr::read_csv(file = &quot;https://covid.ourworldindata.org/data/owid-covid-data.csv&quot;, # ファイルパス／URL col_names = TRUE, # ヘッダー（列名データ）の有無 col_types = NULL, # 各列の型の指定（c：文字列型、d：数値型、D：日付型、l：論理値型） skip = 0) # 読み込み時に上からスキップする行数 ## Rows: 184979 Columns: 67 ## -- Column specification -------------------------------------------------------- ## Delimiter: &quot;,&quot; ## chr (4): iso_code, continent, location, tests_units ## dbl (62): total_cases, new_cases, new_cases_smoothed, total_deaths, new_dea... ## date (1): date ## ## i Use `spec()` to retrieve the full column specification for this data. ## i Specify the column types or set `show_col_types = FALSE` to quiet this message. # データをコンソールに出力 data_owid ## # A tibble: 184,979 x 67 ## iso_code continent location date total_cases new_cases new_cases_smoot~ ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 AFG Asia Afghani~ 2020-02-24 5 5 NA ## 2 AFG Asia Afghani~ 2020-02-25 5 0 NA ## 3 AFG Asia Afghani~ 2020-02-26 5 0 NA ## 4 AFG Asia Afghani~ 2020-02-27 5 0 NA ## 5 AFG Asia Afghani~ 2020-02-28 5 0 NA ## 6 AFG Asia Afghani~ 2020-02-29 5 0 0.714 ## 7 AFG Asia Afghani~ 2020-03-01 5 0 0.714 ## 8 AFG Asia Afghani~ 2020-03-02 5 0 0 ## 9 AFG Asia Afghani~ 2020-03-03 5 0 0 ## 10 AFG Asia Afghani~ 2020-03-04 5 0 0 ## # ... with 184,969 more rows, and 60 more variables: total_deaths &lt;dbl&gt;, ## # new_deaths &lt;dbl&gt;, new_deaths_smoothed &lt;dbl&gt;, total_cases_per_million &lt;dbl&gt;, ## # new_cases_per_million &lt;dbl&gt;, new_cases_smoothed_per_million &lt;dbl&gt;, ## # total_deaths_per_million &lt;dbl&gt;, new_deaths_per_million &lt;dbl&gt;, ## # new_deaths_smoothed_per_million &lt;dbl&gt;, reproduction_rate &lt;dbl&gt;, ## # icu_patients &lt;dbl&gt;, icu_patients_per_million &lt;dbl&gt;, hosp_patients &lt;dbl&gt;, ## # hosp_patients_per_million &lt;dbl&gt;, weekly_icu_admissions &lt;dbl&gt;, ... 次に、内閣府の県内総生産データを読み込みます（生産側、名目、2008SNA、平成23年基準計数）。詳細はこちらを参照してください。ここではデータをdata.frame形式で読み込み、前処理して縦型のtibble形式に変換します。 # 内閣府の県内総生産データをdata.frame形式で読み込み data_gdp_pref &lt;- openxlsx::read.xlsx(xlsxFile = &quot;https://www.esri.cao.go.jp/jp/sna/data/data_list/kenmin/files/contents/tables/2018/soukatu1.xlsx&quot;, # ファイルパス／URL sheet = 1, # シートインデックス／シート名 startRow = 5, # 読み込み開始行 colNames = TRUE, # 列名データの有無 rowNames = FALSE, # 行名データの有無 rows = 5:53, # 読み込む列（NULLですべて読み込み） cols = NULL) # 読み込む行（NULLですべて読み込み） # データの型変換等を行い、縦型に変形したうえで、変化率系列を作成し、tibble形式に変換 data_gdp_pref %&lt;&gt;% dplyr::mutate(across(`2006`:`2018`, as.double)) %&gt;% dplyr::rename(pref_code = X1, pref_name = X2) %&gt;% dplyr::select(-X16) %&gt;% tidyr::pivot_longer(cols = c(-&quot;pref_code&quot;, -&quot;pref_name&quot;), names_to = &quot;year&quot;, values_to = &quot;gdp_nominal&quot;) %&gt;% dplyr::mutate(across(c(pref_code, year), as.double)) %&gt;% dplyr::arrange(pref_code, year) %&gt;% dplyr::group_by(pref_name) %&gt;% dplyr::mutate(gdp_nominal_pchg = 100 * (gdp_nominal / dplyr::lag(gdp_nominal, n = 1) - 1)) %&gt;% dplyr::ungroup() %&gt;% tibble::as_tibble() data_gdp_pref ## # A tibble: 611 x 5 ## pref_code pref_name year gdp_nominal gdp_nominal_pchg ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 北海道 2006 19316568 NA ## 2 1 北海道 2007 19137599 -0.927 ## 3 1 北海道 2008 18457858 -3.55 ## 4 1 北海道 2009 18219113 -1.29 ## 5 1 北海道 2010 18122675 -0.529 ## 6 1 北海道 2011 18071493 -0.282 ## 7 1 北海道 2012 17923502 -0.819 ## 8 1 北海道 2013 18242119 1.78 ## 9 1 北海道 2014 18579766 1.85 ## 10 1 北海道 2015 19128504 2.95 ## # ... with 601 more rows 4.5 GUI形式の直感的なグラフ作成 本節ではggplot2パッケージによるグラフ作成を行いますが、ggplot2はすべてコードを書いてグラフを作成するため、探索的データ分析（EDA）には不向きです。そこで、ggplot2によるグラフ作成を行う前に、GUIによるノーコードのグラフ作成パッケージを用い、どのようなグラフを作成するべきか検討します。 esquisseパッケージ esquisseパッケージは、ドラッグ＆ドロップでX軸・Y軸の変数や色・サイズを変化させる属性の変数を指定し、グラフを作成します。esquisseは便利なパッケージですが、データセットの規模が大きいと起動に時間がかかるため、変数の数が多い場合は、あらかじめ注目する変数を絞るといった前処理が必要です。 # irisデータ esquisse::esquisser(data = iris) ## 世界の新型コロナデータの一部を抽出 data_owid %&gt;% dplyr::select(location, date, new_cases_smoothed) %&gt;% dplyr::filter(location %in% c(&quot;Japan&quot;, &quot;United States&quot;, &quot;United Kingdom&quot;, &quot;Germany&quot;, &quot;France&quot;, &quot;Italy&quot;)) %&gt;% esquisse::esquisser() ggplotguiパッケージ その他のGUIによるノーコードのグラフ作成パッケージには、ggplotguiがあります。 # irisデータ ggplotgui::ggplot_shiny(data = iris) ## 世界の新型コロナデータの一部を抽出 data_owid %&gt;% dplyr::select(location, date, new_cases_smoothed) %&gt;% dplyr::filter(location %in% c(&quot;Japan&quot;, &quot;United States&quot;, &quot;United Kingdom&quot;, &quot;Germany&quot;, &quot;France&quot;, &quot;Italy&quot;)) %&gt;% ggplotgui::ggplot_shiny() 4.6 ヒストグラム ヒストグラムはgeom_histogram()関数で作成します。 X軸：連続型変数 Y軸：なし ヒストグラムの基本形 ggplot(data = mpg, mapping = aes(x = hwy)) + geom_histogram(binwidth = 5, # 階級幅 color = &quot;gray&quot;, # 線の色 fill = &quot;darkblue&quot;, # 塗りつぶしの色 size = 0.5) # 線の太さ 横並びヒストグラム グループ別のヒストグラムを横並び形式で作成するには、position引数に\"dodge\"を指定します。 ggplot(data = mpg, mapping = aes(x = hwy, fill = class)) + geom_histogram(binwidth = 5, # 階級幅 position = &quot;dodge&quot;, # 横並びポジション color = &quot;black&quot;, # 線の色 size = 0.5) # 線の太さ 積み上げヒストグラム グループ別のヒストグラムを積み上げ形式で作成するには、position引数に\"stack\"を指定します。 ggplot(data = mpg, mapping = aes(x = hwy, fill = class)) + geom_histogram(binwidth = 5, # 階級幅 position = &quot;stack&quot;, # 積み上げポジション color = &quot;black&quot;, # 線の色 size = 0.5) # 線の太さ 4.7 密度グラフ 密度グラフはgeom_density()関数で作成します。 X軸：連続型変数 Y軸：なし 密度グラフの基本形 ggplot(data = mpg, mapping = aes(x = hwy)) + geom_density(kernel = &quot;gaussian&quot;, # カーネル関数の種類 color = &quot;darkblue&quot;, # 線の色 linetype = &quot;solid&quot;, # 線の種類（solid / dashed / dotted / dotdash / twodash / longdash） size = 1.0) # 線の太さ 横並び密度グラフ グループ別の密度グラフを横並び形式で作成するには、position引数に\"dodge\"を指定します。 ggplot(data = mpg, mapping = aes(x = hwy, color = class)) + geom_density(kernel = &quot;gaussian&quot;, # カーネル関数の種類 position = &quot;dodge&quot;, # 横並びポジション linetype = &quot;solid&quot;, # 線の種類（solid / dashed / dotted / dotdash / twodash / longdash） size = 1.0) # 線の太さ 積み上げ密度グラフ グループ別の密度グラフを積み上げ形式で作成するには、position引数に\"stack\"を指定します。 ggplot(data = mpg, mapping = aes(x = hwy, fill = class)) + geom_density(kernel = &quot;gaussian&quot;, # カーネル関数の種類 position = &quot;stack&quot;, # 積み上げポジション color = &quot;black&quot;, # 線の色 linetype = &quot;solid&quot;, # 線の種類（solid / dashed / dotted / dotdash / twodash / longdash） size = 0.5) # 線の太さ 4.8 頻度棒グラフ 頻度棒グラフはgeom_bar()関数で作成します。 X軸：離散型変数 Y軸：なし 頻度棒グラフの基本形 ggplot(data = mpg, mapping = aes(x = manufacturer)) + geom_bar(alpha = 1.0, # 塗りつぶしの透明度 color = &quot;darkblue&quot;, # 線の色 fill = &quot;lightblue&quot;, # 塗りつぶしの色 size = 0.5, # 線の太さ width = 0.9) # 棒の幅 (0-1) 4.9 頻度バブルチャート 頻度バブルチャートはgeom_count()関数で作成します。 X軸：離散型変数 Y軸：離散型変数 頻度バブルチャートの基本形 ggplot(data = mpg, mapping = aes(x = manufacturer, y = class)) + geom_count(alpha = 0.5, # 塗りつぶしの透明度 color = &quot;darkblue&quot;, # 線の色 fill = &quot;lightblue&quot;, # 塗りつぶしの色 shape = 21, # マーカーの種類 stroke = 0.5) + # 線の太さ scale_size_area(max_size = 15) + # 変量とマーカーの面積を比例させる theme(axis.text.x = element_text(angle = 45, hjust = 1.0)) 4.10 散布図・バブルチャート 散布図とバブルチャートはgeom_point()関数で作成します。バブルチャートの上にgeom_smooth()関数で近似曲線を重ねることができます。 X軸：連続型変数 Y軸：連続型変数 まず、プロット用のデータを作成します。 data_mpg_point &lt;- mpg %&gt;% dplyr::group_by(manufacturer) %&gt;% dplyr::summarise(across(c(displ, cty, hwy), mean, na.rm = TRUE)) data_mpg_point ## # A tibble: 15 x 4 ## manufacturer displ cty hwy ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 audi 2.54 17.6 26.4 ## 2 chevrolet 5.06 15 21.9 ## 3 dodge 4.38 13.1 17.9 ## 4 ford 4.54 14 19.4 ## 5 honda 1.71 24.4 32.6 ## 6 hyundai 2.43 18.6 26.9 ## 7 jeep 4.58 13.5 17.6 ## 8 land rover 4.3 11.5 16.5 ## 9 lincoln 5.4 11.3 17 ## 10 mercury 4.4 13.2 18 ## 11 nissan 3.27 18.1 24.6 ## 12 pontiac 3.96 17 26.4 ## 13 subaru 2.46 19.3 25.6 ## 14 toyota 2.95 18.5 24.9 ## 15 volkswagen 2.26 20.9 29.2 散布図の基本形 ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) + geom_point(alpha = 1.0, # 塗りつぶしの透明度 color = &quot;darkblue&quot;, # 線の色 fill = &quot;lightblue&quot;, # 塗りつぶしの色 shape = 21, # マーカーの種類 size = 2.0, # マーカーの大きさ stroke = 0.5) # 線の太さ バブルチャートの基本形 バブルチャートを作成するには、ggplot()関数のmapping = aes()関数でsize引数にバブルのサイズを変化させたい変数を指定します。 ggplot(data = data_mpg_point, mapping = aes(x = cty, y = hwy, size = displ)) + # aes() 関数内のsize引数に連続型変数を指定 geom_point(alpha = 1.0, # 塗りつぶしの透明度 color = &quot;darkblue&quot;, # 線の色 fill = &quot;lightblue&quot;, # 塗りつぶしの色 shape = 21, # マーカーの種類 stroke = 0.5) # 線の太さ 散布図に補助線を追加 水平線、垂直線、傾き・切片のある直線といった補助線を追加するには、それぞれgeom_hline()関数、geom_vline()関数、geom_abline()関数を使用します。 ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) + geom_hline(yintercept = 20, # 水平線の縦軸との交点 color = &quot;Tomato&quot;, # 水平線の色 size = 0.5) + # 水平線の太さ geom_vline(xintercept = 20, # 垂直線の横軸との交点 color = &quot;Forestgreen&quot;, # 垂直線の色 size = 0.5) + # 垂直線の太さ geom_abline(intercept = 0, # 直線の切片 slope = 1, # 直線の傾き color = &quot;gold&quot;, # 直線の色 size = 0.5) + # 直線の太さ geom_point(alpha = 1.0, # 塗りつぶしの透明度 color = &quot;darkblue&quot;, # 線の色 fill = &quot;lightblue&quot;, # 塗りつぶしの色 shape = 21, # マーカーの種類 size = 2.0, # マーカーの大きさ stroke = 0.5) # 線の太さ 散布図にコネクタ線を追加 散布図のマーカー間をつなぐコネクタ線を追加するには、geom_path()関数を追加します。折れ線グラフを作成するgeom_line()関数とは異なるので注意してください。 geom_path()関数とgeom_line()関数はどちらもマーカー間をつなぐコネクタ線を追加する関数ですが、geom_path()関数はデータセット上の順番で線を引く一方、geom_line()関数はデータセット上の順番に関わらずX軸上の順番で線を引くという違いがあります。 economics %&gt;% dplyr::filter(date &gt;= &quot;2000-01-01&quot;) %&gt;% ggplot(mapping = aes(x = unemploy, y = uempmed)) + geom_path(alpha = 1.0, # 塗りつぶしの透明度 color = &quot;darkblue&quot;, # 線の色 size = 0.5) + # 線の大きさ geom_point(alpha = 1.0, # 塗りつぶしの透明度 color = &quot;darkblue&quot;, # 線の色 fill = &quot;lightblue&quot;, # 塗りつぶしの色 shape = 21, # マーカーの種類 size = 2.0, # マーカーの大きさ stroke = 0.5) # 線の太さ 散布図に近似曲線を追加 散布図に近似曲線を追加するには、geom_smooth()関数を使用します。 ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) + geom_point(alpha = 1.0, # 塗りつぶしの透明度 color = &quot;darkblue&quot;, # 線の色 fill = &quot;lightblue&quot;, # 塗りつぶしの色 shape = 21, # マーカーの種類 size = 2.0, # マーカーの大きさ stroke = 0.5) + # 線の太さ geom_smooth(formula = y ~ x, # 近似曲線の推計式 method = &quot;loess&quot;, # 近似手法 (lm, glm, gam, loess) alpha = 0.5, # 誤差範囲の透明度 color = &quot;black&quot;, # 近似曲線の色 fill = &quot;gray&quot;, # 誤差範囲の色 linetype = &quot;dashed&quot;, # 近似曲線の種類（solid / dashed / dotted / dotdash / twodash / longdash） size = 1.0) # 近似曲線の太さ 散布図にラベルを追加 散布図にラベルを追加するには、ggrepelパッケージのgeom_text_repel()関数を使用します。geom_text_repel()関数は、散布図のマーカーとラベルが重ならないようにラベルの位置を自動で調整します。 ggplot(data = data_mpg_point, mapping = aes(x = cty, y = hwy)) + geom_point(alpha = 1.0, # 塗りつぶしの透明度 color = &quot;darkblue&quot;, # 線の色 fill = &quot;lightblue&quot;, # 塗りつぶしの色 shape = 21, # マーカーの種類 size = 2.0, # マーカーの大きさ stroke = 0.5) + # 線の太さ geom_text_repel(mapping = aes(label = manufacturer), seed = NA, # テキストの配置を決定するランダムシード direction = &quot;both&quot;, # テキストの整列方向 (both / x / y) hjust = 0.0, # 横方向の整列位置 (0-1) vjust = 0.5, # 縦方向の整列位置 (0-1) nudge_x = NULL, # マーカーからの横方向のスペース (NULL, 0-) nudge_y = NULL, # マーカーからの縦方向のスペース (NULL, 0-) box.padding = 0.5, # テキスト周囲のスペース (0-) point.padding = 0.1, # マーカー周囲のスペース (0-) segment.alpha = 1.0, # 引き出し線の透明度 segment.color = &quot;grey&quot;, # 引き出し線の色 segment.size = 0.5, # 引き出し線の太さ min.segment.length = 0, # 引き出し線の最低長 color = &quot;black&quot;, # テキストの色 family = &quot;YUGO&quot;, # テキストのフォント fontface = &quot;plain&quot;, # テキストの書体 (plain / bold / italic / bold.italic) size = 4.0) # テキストのサイズ 4.10.1 バブルチャートにラベルを追加 ggplot(data = data_mpg_point, mapping = aes(x = cty, y = hwy, size = displ)) + # aes() 関数内のsize引数に連続型変数を指定 geom_point(alpha = 1.0, # 塗りつぶしの透明度 color = &quot;darkblue&quot;, # 線の色 fill = &quot;lightblue&quot;, # 塗りつぶしの色 shape = 21, # マーカーの種類 stroke = 0.5) + # 線の太さ geom_text_repel(mapping = aes(label = manufacturer), seed = NA, # テキストの配置を決定するランダムシード direction = &quot;both&quot;, # テキストの整列方向 (both / x / y) hjust = 0.0, # 横方向の整列位置 (0-1) vjust = 0.5, # 縦方向の整列位置 (0-1) nudge_x = NULL, # マーカーからの横方向のスペース (NULL, 0-) nudge_y = NULL, # マーカーからの縦方向のスペース (NULL, 0-) box.padding = 1.0, # テキスト周囲のスペース (0-) point.padding = 0.1, # マーカー周囲のスペース (0-) segment.alpha = 1.0, # 引き出し線の透明度 segment.color = &quot;grey&quot;, # 引き出し線の色 segment.size = 0.5, # 引き出し線の太さ min.segment.length = 0, # 引き出し線の最低長 color = &quot;black&quot;, # テキストの色 family = &quot;YUGO&quot;, # テキストのフォント fontface = &quot;plain&quot;, # テキストの書体 (plain / bold / italic / bold.italic) size = 4.0) + # テキストのサイズ scale_size_area(max_size = 15) # 変量とマーカーの面積を比例させる 4.11 棒グラフ 棒グラフはgeom_col()関数で作成します。 X軸：離散型変数 Y軸：連続型変数 まず、プロット用のデータを作成します。 data_mpg_col &lt;- mpg %&gt;% dplyr::group_by(manufacturer) %&gt;% dplyr::summarise(across(c(cty, hwy), mean, na.rm = TRUE)) data_mpg_col ## # A tibble: 15 x 3 ## manufacturer cty hwy ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 audi 17.6 26.4 ## 2 chevrolet 15 21.9 ## 3 dodge 13.1 17.9 ## 4 ford 14 19.4 ## 5 honda 24.4 32.6 ## 6 hyundai 18.6 26.9 ## 7 jeep 13.5 17.6 ## 8 land rover 11.5 16.5 ## 9 lincoln 11.3 17 ## 10 mercury 13.2 18 ## 11 nissan 18.1 24.6 ## 12 pontiac 17 26.4 ## 13 subaru 19.3 25.6 ## 14 toyota 18.5 24.9 ## 15 volkswagen 20.9 29.2 data_owid_col &lt;- data_owid %&gt;% dplyr::select(location, date, new_cases) %&gt;% dplyr::filter(location %in% c(&quot;Japan&quot;, &quot;United Kingdom&quot;, &quot;Germany&quot;, &quot;France&quot;, &quot;Italy&quot;)) %&gt;% dplyr::mutate(year = str_c(lubridate::year(date), &quot;年&quot;), .after = &quot;date&quot;) %&gt;% dplyr::group_by(location, year) %&gt;% dplyr::summarise(across(new_cases, sum, na.rm = TRUE)) data_owid_col ## # A tibble: 15 x 3 ## # Groups: location [5] ## location year new_cases ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 France 2020年 2735590 ## 2 France 2021年 7706191 ## 3 France 2022年 19000942 ## 4 Germany 2020年 1719737 ## 5 Germany 2021年 5430685 ## 6 Germany 2022年 18256502 ## 7 Italy 2020年 2107314 ## 8 Italy 2021年 4018517 ## 9 Italy 2022年 10690736 ## 10 Japan 2020年 235747 ## 11 Japan 2021年 1496547 ## 12 Japan 2022年 6394176 ## 13 United Kingdom 2020年 2491790 ## 14 United Kingdom 2021年 10480124 ## 15 United Kingdom 2022年 8402779 縦棒グラフの基本形 ggplot(data = data_mpg_col, mapping = aes(x = manufacturer, y = cty)) + geom_col(alpha = 1.0, # 塗りつぶしの透明度 color = &quot;darkblue&quot;, # 線の色 fill = &quot;lightblue&quot;, # 塗りつぶしの色 size = 0.5, # 線の太さ width = 0.9) + # 棒の幅 (0-1) theme(axis.text.x = element_text(angle = 45, hjust = 1.0)) 横棒グラフ 横棒グラフを作成するには、縦棒グラフを作成した後にcoord_flip()関数で横棒グラフに転換します。そのため、X軸とY軸の変数指定は縦棒グラフの場合と同じです。 ggplot(data = data_mpg_col, mapping = aes(x = manufacturer, y = cty)) + geom_col(alpha = 1.0, # 塗りつぶしの透明度 color = &quot;darkblue&quot;, # 線の色 fill = &quot;lightblue&quot;, # 塗りつぶしの色 size = 0.5, # 線の太さ width = 0.9) + # 棒の幅 (0-1) coord_flip() 縦棒グラフの順序並べ替え 縦棒グラフのX軸の順番を並べ替えるには、X軸の変数を指定する際にfct_reorder()関数を使用します。 ggplot(data = data_mpg_col, mapping = aes(x = fct_reorder(manufacturer, -cty), y = cty)) + geom_col(alpha = 1.0, # 塗りつぶしの透明度 color = &quot;darkblue&quot;, # 線の色 fill = &quot;lightblue&quot;, # 塗りつぶしの色 size = 0.5, # 線の太さ width = 0.9) + # 棒の幅 (0-1) theme(axis.text.x = element_text(angle = 45, hjust = 1.0)) 縦棒グラフにラベルを追加 縦棒グラフにデータラベルを追加するには、geom_text()関数を使用します。 ggplot(data = data_mpg_col, mapping = aes(x = fct_reorder(manufacturer, -cty), y = cty)) + geom_col(alpha = 1.0, # 塗りつぶしの透明度 color = &quot;darkblue&quot;, # 線の色 fill = &quot;lightblue&quot;, # 塗りつぶしの色 size = 0.5, # 線の太さ width = 0.9) + # 棒の幅 (0-1) geom_text(mapping = aes(label = cty %&gt;% sprintf(fmt = &quot;%0.1f&quot;)), # sprintf() 関数で数値の表示形式を指定 vjust = -1, # 縦方向の整列位置 (0-1) color = &quot;black&quot;, # テキストの色 family = &quot;YUGO&quot;, # テキストのフォント fontface = &quot;plain&quot;, # テキストの書体 (plain / bold / italic / bold.italic) size = 4.0) + # テキストのサイズ theme(axis.text.x = element_text(angle = 45, hjust = 1.0)) 横並び縦棒グラフ 複数の縦棒グラフを横並び形式で作成するには、position引数にposition_dodge()関数を指定します。 ggplot(data = data_owid_col, mapping = aes(x = location, y = new_cases, fill = year, group = rev(year))) + geom_col(position = position_dodge(width = 0.5), # 横並びポジション alpha = 1.0, # 塗りつぶしの透明度 size = 0.5, # 線の太さ width = 0.9) # 棒の幅 (0-1) 積み上げ縦棒グラフ 複数の縦棒グラフを積み上げ形式で作成するには、position引数にposition_stack()関数を指定します。 ggplot(data = data_owid_col, mapping = aes(x = location, y = new_cases, fill = year, group = rev(year))) + geom_col(position = position_stack(), # 積み上げポジション alpha = 1.0, # 塗りつぶしの透明度 size = 0.5, # 線の太さ width = 0.9) + # 棒の幅 (0-1) guides(fill = guide_legend(reverse = TRUE)) 積み上げ縦棒グラフにラベルを追加 ggplot(data = data_owid_col, mapping = aes(x = location, y = new_cases, fill = year, group = rev(year))) + geom_col(position = position_stack(), # 積み上げポジション alpha = 1.0, # 塗りつぶしの透明度 size = 0.5, # 線の太さ width = 0.9) + # 棒の幅 (0-1) geom_text(mapping = aes(label = new_cases %&gt;% sprintf(fmt = &quot;%0.1f&quot;)), # sprintf() 関数で数値の表示形式を指定 position = position_stack(vjust = 0.5), # position_stack() 関数で積み上げ棒グラフ上のラベル位置を指定 color = &quot;white&quot;, # テキストの色 family = &quot;YUGO&quot;, # テキストのフォント fontface = &quot;plain&quot;, # テキストの書体 (plain / bold / italic / bold.italic) size = 4.0) + # テキストのサイズ guides(fill = guide_legend(reverse = TRUE)) シェア縦棒グラフ 複数の縦棒グラフを合計が100％になるシェア積み上げ形式で作成するには、position引数にposition_fill()関数を指定します。 ggplot(data = data_owid_col, mapping = aes(x = location, y = new_cases, fill = year, group = rev(year))) + geom_col(position = position_fill(), # 割合積み上げポジション alpha = 1.0, # 塗りつぶしの透明度 size = 0.5, # 線の太さ width = 0.9) + # 棒の幅 (0-1) guides(fill = guide_legend(reverse = TRUE)) シェア縦棒グラフにラベルを追加 data_owid_col %&gt;% dplyr::group_by(location) %&gt;% dplyr::mutate(percent = new_cases / sum(new_cases)) %&gt;% ggplot(mapping = aes(x = location, y = new_cases, fill = year, group = rev(year))) + geom_col(position = position_fill(), # 割合ポジション alpha = 1.0, # 塗りつぶしの透明度 size = 0.5, # 線の太さ width = 0.9) + # 棒の幅 (0-1) geom_text(mapping = aes(label = percent %&gt;% sprintf(fmt = &quot;%0.2f&quot;)), # sprintf() 関数で数値の表示形式を指定 position = position_fill(vjust = 0.5), # position_fill() 関数で割合棒グラフ上のラベル位置を指定 color = &quot;white&quot;, # テキストの色 family = &quot;YUGO&quot;, # テキストのフォント fontface = &quot;plain&quot;, # テキストの書体 (plain / bold / italic / bold.italic) size = 4.0) + # テキストのサイズ guides(fill = guide_legend(reverse = TRUE)) 4.12 円グラフ 円グラフを作成するには、geom_col()関数で積み上げ棒グラフを作成した後にcoord_polar()関数で円グラフに転換します。 X軸：単一の値 Y軸：連続型変数 まず、プロット用のデータを作成します。 data_mpg_circle &lt;- mpg %&gt;% dplyr::group_by(class) %&gt;% dplyr::summarise(across(c(hwy), mean, na.rm = TRUE)) data_mpg_circle ## # A tibble: 7 x 2 ## class hwy ## &lt;chr&gt; &lt;dbl&gt; ## 1 2seater 24.8 ## 2 compact 28.3 ## 3 midsize 27.3 ## 4 minivan 22.4 ## 5 pickup 16.9 ## 6 subcompact 28.1 ## 7 suv 18.1 円グラフの基本形 ggplot(data = data_mpg_circle, mapping = aes(x = 1, y = hwy, fill = class, group = rev(class))) + geom_col(position = position_stack(), # 積み上げポジション alpha = 1.0, # 塗りつぶしの透明度 color = &quot;grey&quot;, # 線の色 size = 0.5) + # 線の太さ geom_text(mapping = aes(label = hwy %&gt;% sprintf(fmt = &quot;%0.1f&quot;)), # sprintf() 関数で数値の表示形式を指定 position = position_stack(vjust = 0.5), # position_stack() 関数で積み上げ棒グラフ上のラベル位置を指定 color = &quot;white&quot;, # テキストの色 family = &quot;YUGO&quot;, # テキストのフォント fontface = &quot;plain&quot;, # テキストの書体 (plain / bold / italic / bold.italic) size = 4.0) + # テキストのサイズ coord_polar(theta = &quot;y&quot;, # 円グラフを作成する軸 start = 0, # 円グラフの開始位置（ラジアン） direction = 1) + # 円グラフの方向（1：時計回り、-1：反時計回り） theme(panel.grid = element_blank(), # パネルの軸や目盛り線を表示しない axis.title = element_blank(), axis.text = element_blank(), axis.ticks = element_blank()) + guides(fill = guide_legend(reverse = FALSE)) 4.13 折れ線グラフ 折れ線グラフは時系列的に変化するデータを可視化する最も基本的なグラフで、geom_line()関数で作成します。 X軸：日付型変数 Y軸：連続型変数 まず、プロット用のデータを作成します。 data_owid_line &lt;- data_owid %&gt;% dplyr::select(location, date, new_cases_smoothed) %&gt;% dplyr::filter(location %in% c(&quot;Japan&quot;, &quot;United Kingdom&quot;, &quot;Germany&quot;, &quot;France&quot;, &quot;Italy&quot;), date &gt;= &quot;2022-01-01&quot;) %&gt;% tidyr::drop_na(everything()) data_owid_line ## # A tibble: 643 x 3 ## location date new_cases_smoothed ## &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; ## 1 France 2022-01-01 157705. ## 2 France 2022-01-02 162095. ## 3 France 2022-01-03 167381. ## 4 France 2022-01-04 180515. ## 5 France 2022-01-05 198252. ## 6 France 2022-01-06 206286. ## 7 France 2022-01-07 220003. ## 8 France 2022-01-08 232080. ## 9 France 2022-01-09 266032. ## 10 France 2022-01-10 269809. ## # ... with 633 more rows 折れ線グラフの基本形 ggplot(data = economics, mapping = aes(x = date, y = unemploy)) + geom_line(alpha = 1.0, # 線の透明度 color = &quot;darkblue&quot;, # 線の色 linetype = &quot;solid&quot;, # 線の種類（solid / dashed / dotted / dotdash / twodash / longdash） size = 1.0) # 線の太さ 折れ線グラフにマーカーを追加 折れ線グラフを作成するgeom_line()関数と、散布図を作成するgeom_point()関数を併用します。 ggplot(data = economics, mapping = aes(x = date, y = unemploy)) + geom_line(alpha = 1.0, # 線の透明度 color = &quot;darkblue&quot;, # 線の色 linetype = &quot;solid&quot;, # 線の種類（solid / dashed / dotted / dotdash / twodash / longdash） size = 1.0) + # 線の太さ geom_point(alpha = 1.0, # 塗りつぶしの透明度 color = &quot;darkblue&quot;, # 線の色 fill = &quot;lightblue&quot;, # 塗りつぶしの色 shape = 21, # マーカーの種類 size = 2.0, # マーカーの大きさ stroke = 0.5) # 線の太さ 折れ線グラフに系列ラベルを追加 折れ線グラフの数が多く凡例が分かりにくい場合などに、折れ線グラフの右側に系列名のラベルを追加します。ラベルを追加するには、ggrepelパッケージのgeom_text_repel関数を使用します。 ggplot(data = data_owid_line, mapping = aes(x = date, y = new_cases_smoothed, color = location)) + geom_line(alpha = 1.0, # 線の透明度 linetype = &quot;solid&quot;, # 線の種類（solid / dashed / dotted / dotdash / twodash / longdash） size = 1.0) + # 線の太さ geom_text_repel(data = data_owid_line %&gt;% dplyr::group_by(location) %&gt;% dplyr::filter(date == max(date)), mapping = aes(x = date, y = new_cases_smoothed, label = location), seed = NA, # テキストの配置を決定するランダムシード direction = &quot;y&quot;, # テキストの整列方向 (both / x / y) hjust = 0.0, # 横方向の整列位置 (0-1) vjust = 0.5, # 縦方向の整列位置 (0-1) nudge_x = 5, # マーカーからの横方向のスペース (NULL, 0-) nudge_y = NULL, # マーカーからの縦方向のスペース (NULL, 0-) box.padding = 0.1, # テキスト周囲のスペース (0-) point.padding = 0.1, # マーカー周囲のスペース (0-) segment.alpha = 1.0, # 引き出し線の透明度 segment.color = &quot;grey&quot;, # 引き出し線の色 segment.size = 0.5, # 引き出し線の太さ min.segment.length = Inf, # 引き出し線の最低長 family = &quot;YUGO&quot;, # テキストのフォント fontface = &quot;plain&quot;, # テキストの書体 (plain / bold / italic / bold.italic) size = 3.0) + # テキストのサイズ scale_x_date(date_breaks = &quot;1 month&quot;, # 日付目盛の周期 date_labels = &quot;%y/%b&quot;, # %Y：4桁年、%y：2桁年、%m：2桁月、%b：1桁月、%d：日 limits = c(as.Date(&quot;2022/01/01&quot;), NA), # 始期・終期（指定しない場合はNA） expand = expansion(mult = c(0.00, 0.2), add = c(0, 0))) + # 始期・終期からの余白（multは余白率、addは余白幅） theme(legend.position = &quot;none&quot;) 4.14 ステップグラフ ステップグラフは折れ線グラフの特殊形です。政策金利のように、段階的に値が変化するデータに適しています。ステップグラフはgeom_step()関数で作成します。 X軸：日付型変数 Y軸：連続型変数 まず、サンプルデータを作成します。ここでは、Our World in Dataが提供する新型コロナウイルス感染対策の厳格度を示すStringency Indexを用います。 data_owid_step &lt;- data_owid %&gt;% dplyr::select(location, date, stringency_index) %&gt;% dplyr::filter(location %in% c(&quot;Japan&quot;, &quot;United Kingdom&quot;, &quot;Germany&quot;, &quot;France&quot;, &quot;Italy&quot;)) data_owid_step ## # A tibble: 4,170 x 3 ## location date stringency_index ## &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; ## 1 France 2020-01-24 5.56 ## 2 France 2020-01-25 5.56 ## 3 France 2020-01-26 5.56 ## 4 France 2020-01-27 5.56 ## 5 France 2020-01-28 5.56 ## 6 France 2020-01-29 5.56 ## 7 France 2020-01-30 5.56 ## 8 France 2020-01-31 5.56 ## 9 France 2020-02-01 5.56 ## 10 France 2020-02-02 5.56 ## # ... with 4,160 more rows ステップグラフの基本形 ggplot(data = data_owid_step, mapping = aes(x = date, y = stringency_index, color = location)) + geom_step(alpha = 1.0, # 線の透明度 linetype = &quot;solid&quot;, # 線の種類（solid / dashed / dotted / dotdash / twodash / longdash） size = 1.0) # 線の太さ 4.15 面グラフ 面グラフは折れ線グラフの特殊形です。面グラフには2種類あり、折れ線グラフとX軸で挟まれた範囲を塗りつぶすグラフはgeom_area()関数、2つの折れ線グラフで挟まれた範囲を塗りつぶすグラフはgeom_ribbon()関数で作成します。後者は特にリボングラフと呼ばれ、信頼区間の可視化に用いることができます。 X軸：日付型変数 Y軸：連続型変数 まず、プロット用のデータを作成します。 data_owid_line &lt;- data_owid %&gt;% dplyr::select(location, date, new_cases_smoothed) %&gt;% dplyr::filter(location %in% c(&quot;Japan&quot;, &quot;United Kingdom&quot;, &quot;Germany&quot;, &quot;France&quot;, &quot;Italy&quot;), date &gt;= &quot;2022-01-01&quot;) %&gt;% tidyr::drop_na(everything()) data_owid_line ## # A tibble: 643 x 3 ## location date new_cases_smoothed ## &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; ## 1 France 2022-01-01 157705. ## 2 France 2022-01-02 162095. ## 3 France 2022-01-03 167381. ## 4 France 2022-01-04 180515. ## 5 France 2022-01-05 198252. ## 6 France 2022-01-06 206286. ## 7 France 2022-01-07 220003. ## 8 France 2022-01-08 232080. ## 9 France 2022-01-09 266032. ## 10 France 2022-01-10 269809. ## # ... with 633 more rows 面グラフの基本形 ggplot(data = economics, mapping = aes(x = date, y = unemploy)) + geom_area(alpha = 1.0, # 線の透明度 color = &quot;darkblue&quot;, # 線の色 fill = &quot;lightblue&quot;, # 塗りつぶしの色 linetype = &quot;solid&quot;, # 線の種類（solid / dashed / dotted / dotdash / twodash / longdash） size = 1.0) # 線の太さ 積み上げ面グラフ 複数の面グラフを積み上げ形式で作成するには、position引数にposition_stack()関数を指定します。 data_owid_line %&gt;% dplyr::mutate(location = factor(location, levels = c(&quot;Japan&quot;, &quot;United Kingdom&quot;, &quot;Germany&quot;, &quot;France&quot;, &quot;Italy&quot;) %&gt;% rev())) %&gt;% ggplot(mapping = aes(x = date, y = new_cases_smoothed, fill = location)) + geom_area(position = position_stack(), alpha = 1.0, # 線の透明度 linetype = &quot;solid&quot;, # 線の種類（solid / dashed / dotted / dotdash / twodash / longdash） size = 1.0) # 線の太さ リボングラフの基本形 リボングラフでは、aes()関数の中で塗りつぶし範囲の下端をymin引数、上端をymax引数に指定します。 data_owid_line %&gt;% dplyr::group_by(date) %&gt;% dplyr::summarise(new_cases_max = max(new_cases_smoothed, na.rm = TRUE), new_cases_min = min(new_cases_smoothed, na.rm = TRUE)) %&gt;% ggplot(mapping = aes(x = date, ymin = new_cases_min, ymax = new_cases_max)) + geom_ribbon(alpha = 1.0, # 線の透明度 color = &quot;darkblue&quot;, # 線の色 fill = &quot;lightblue&quot;, # 塗りつぶしの色 linetype = &quot;solid&quot;, # 線の種類（solid / dashed / dotted / dotdash / twodash / longdash） size = 0.5) # 線の太さ リボングラフに折れ線グラフを追加 リボングラフに折れ線グラフを追加する際は、まずgeom_ribbon()関数でリボングラフを作成し、そのあとに+でgeom_line()関数をつなげて折れ線グラフを追加します。 data_owid_line %&gt;% dplyr::group_by(date) %&gt;% dplyr::summarise(new_cases_max = max(new_cases_smoothed, na.rm = TRUE), new_cases_median = median(new_cases_smoothed, na.rm = TRUE), new_cases_min = min(new_cases_smoothed, na.rm = TRUE)) %&gt;% ggplot(mapping = aes(x = date, ymin = new_cases_min, ymax = new_cases_max, y = new_cases_median)) + geom_ribbon(alpha = 1.0, # 線の透明度 color = &quot;darkblue&quot;, # 線の色 fill = &quot;lightblue&quot;, # 塗りつぶしの色 linetype = &quot;solid&quot;, # 線の種類（solid / dashed / dotted / dotdash / twodash / longdash） size = 0.5) + # 線の太さ geom_line(alpha = 1.0, # 線の透明度 color = &quot;red&quot;, # 線の色 linetype = &quot;dashed&quot;, # 線の種類（solid / dashed / dotted / dotdash / twodash / longdash） size = 1.0) # 線の太さ 4.16 箱ひげグラフ・ヴァイオリングラフ データの分布範囲を可視化するには箱ひげグラフやヴァイオリングラフを用います。箱ひげグラフはgeom_boxplot()関数、ヴァイオリングラフはgeom_violin()関数で作成します。geom_jitter()関数を併用し、箱ひげグラフやヴァイオリングラフに個別データの位置をプロットすると、データの分布がより具体的に分かりやすくなります。 X軸：離散型変数 Y軸：連続型変数 箱ひげグラフの基本形 箱ひげグラフは一般的に、ひげの下端が最小値、箱の下端が第1四分位数、箱内部の横線が中央値、箱の上端が第3四分位数、ひげの上端が最大値を表します。しかし、ggplot2パッケージのgeom_boxplot()で作成すると、ひげの下端・上端は箱の下端・上端から1.5×IQRの範囲内にある最小・最大のサンプルの位置を表すことに注意が必要です。その範囲外にあるサンプルは外れ値として扱われます。なお、IQRは四分位範囲（第3四分位数-第1四分位数）を意味します。 ggplot(data = mpg, mapping = aes(x = class, y = hwy)) + geom_boxplot(outlier.alpha = 1.0, # 外れ値マーカーの塗りつぶしの透明度 outlier.color = &quot;darkblue&quot;, # 外れ値マーカーの線の色 outlier.fill = &quot;lightblue&quot;, # 外れ値マーカーの塗りつぶしの色 outlier.shape = 21, # 外れ値マーカーの種類（外れ値を表示しない場合はNA） outlier.size = 2.0, # 外れ値マーカーの大きさ outlier.stroke = 0.5, # 外れ値マーカーの線の太さ alpha = 0.5, # 箱の塗りつぶしの透明度 color = &quot;darkblue&quot;, # 箱ひげの線の色 fill = &quot;lightblue&quot;, # 箱の塗りつぶしの色 size = 0.5) # 箱ひげの線の太さ 箱ひげグラフに個別サンプルを追加 箱ひげグラフに個別サンプルを追加する場合は、データの重複表示を避けるため、geom_boxplot()関数のoutlier.shape引数にNAを指定して、箱ひげグラフによる外れ値のマーカーを非表示にします。 ggplot(data = mpg, mapping = aes(x = class, y = hwy)) + geom_boxplot(outlier.shape = NA, # 外れ値マーカーの種類（外れ値を表示しない場合はNA） alpha = 0.5, # 箱の塗りつぶしの透明度 color = &quot;darkblue&quot;, # 箱ひげの線の色 fill = &quot;lightblue&quot;, # 箱の塗りつぶしの色 size = 0.5) + # 箱ひげの線の太さ geom_jitter(height = 0.3, # マーカーの縦方向の分布範囲 width = 0.3, # マーカーの横方向の分布範囲 alpha = 1.0, # マーカーの塗りつぶしの透明度 color = &quot;darkblue&quot;, # マーカーの線の色 fill = &quot;darkblue&quot;, # マーカーの塗りつぶしの色 shape = 21, # マーカーの種類 size = 1.0, # マーカーの大きさ stroke = 0.5) # マーカーの線の太さ ヴァイオリングラフの基本形 ggplot(data = mpg, mapping = aes(x = class, y = hwy)) + geom_violin(scale = &quot;area&quot;, # ヴァイオリンの大きさ（area：すべての面積が同じ、count：サンプル個数に比例、width：すべての幅が同じ） alpha = 0.5, # ヴァイオリンの塗りつぶしの透明度 color = &quot;darkblue&quot;, # ヴァイオリンの線の色 fill = &quot;lightblue&quot;, # ヴァイオリンの塗りつぶしの色 linetype = &quot;solid&quot;, # ヴァイオリンの線の種類 size = 0.5) # ヴァイオリンの線の太さ ヴァイオリングラフに個別サンプルを追加 ggplot(data = mpg, mapping = aes(x = class, y = hwy)) + geom_violin(scale = &quot;area&quot;, # ヴァイオリンの大きさ（area：すべての面積が同じ、count：サンプル個数に比例、width：すべての幅が同じ） alpha = 0.5, # ヴァイオリンの塗りつぶしの透明度 color = &quot;darkblue&quot;, # ヴァイオリンの線の色 fill = &quot;lightblue&quot;, # ヴァイオリンの塗りつぶしの色 linetype = &quot;solid&quot;, # ヴァイオリンの線の種類 size = 0.5) + # ヴァイオリンの線の太さ geom_jitter(height = 0.4, # マーカーの縦方向の分布範囲 width = 0.4, # マーカーの横方向の分布範囲 alpha = 1.0, # マーカーの塗りつぶしの透明度 color = &quot;darkblue&quot;, # マーカーの線の色 fill = &quot;darkblue&quot;, # マーカーの塗りつぶしの色 shape = 21, # マーカーの種類 size = 1.0, # マーカーの大きさ stroke = 0.5) # マーカーの線の太さ 4.17 ドットプロット ドットプロットはgeom_dotplot()関数で作成します。FOMCで示される参加者の政策金利予想を可視化する際に使用されます。 X軸：離散型変数 Y軸：離散型変数 ドットプロットの基本形 ggplot(data = mpg, mapping = aes(x = class, y = hwy)) + geom_dotplot(binaxis = &quot;y&quot;, binwidth = 0.5, stackdir = &quot;center&quot;, alpha = 1.0, # マーカーの塗りつぶしの透明度 color = &quot;darkblue&quot;, # マーカーの線の色 fill = &quot;lightblue&quot;, # マーカーの塗りつぶしの色 stroke = 0.5) # マーカーの線の太さ 4.18 色の設定 変数の値や属性に応じて色を自動で変化させるには、geom関数ファミリーでグラフを作成したあとに、+でscale_color関数ファミリー（線の色）やscale_fill関数ファミリー（塗りつぶしの色）をつなぎます。色を変化に対応する変数が離散型か連続型かによって、どのscale_color/fill関数を用いるかが変わります。 まず、プロット用のデータを作成します。 data_mpg_color &lt;- mpg %&gt;% dplyr::group_by(class) %&gt;% dplyr::summarise(across(c(cty, hwy), mean, na.rm = TRUE)) data_mpg_color ## # A tibble: 7 x 3 ## class cty hwy ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2seater 15.4 24.8 ## 2 compact 20.1 28.3 ## 3 midsize 18.8 27.3 ## 4 minivan 15.8 22.4 ## 5 pickup 13 16.9 ## 6 subcompact 20.4 28.1 ## 7 suv 13.5 18.1 色の手動指定（離散型変数） 自分で色の割り当てを決める方法です。Rで使用できる色の種類については、こちらを参照してください。 ggplot(data = mpg, mapping = aes(x = fl, color = fl, fill = fl)) + geom_bar() + scale_color_manual(values = c(&quot;Red&quot;, &quot;Salmon&quot;, &quot;Gold&quot;, &quot;Forestgreen&quot;, &quot;Darkblue&quot;)) + # colorで指定した変数の離散値と同数の色を指定 scale_fill_manual(values = c(&quot;Red&quot;, &quot;Salmon&quot;, &quot;Gold&quot;, &quot;Forestgreen&quot;, &quot;Darkblue&quot;)) # fillで指定した変数の離散値と同数の色を指定 Brewerカラーパレット（離散型変数） RColorBrewerパッケージで提供される様々な種類の美麗なプリセットカラーパレットが利用できます。 # カラーパレットの確認 RColorBrewer::display.brewer.all() ggplot(data = mpg, mapping = aes(x = fl, color = fl, fill = fl)) + geom_bar() + scale_color_brewer(palette = &quot;Paired&quot;, # カラーパレット名 direction = 1) + # 色の順序（-1で逆順） scale_fill_brewer(palette = &quot;Paired&quot;, # カラーパレット名 direction = 1) # 色の順序（-1で逆順） Viridisカラーパレット（離散型変数） 色覚障害に対応したカラーパレットです。パレットの種類などの詳細はこちらを参照してください。 ggplot(data = mpg, mapping = aes(x = fl, color = fl, fill = fl)) + geom_bar() + scale_color_viridis_d(option = &quot;viridis&quot;, # パレットの種類（magma / inferno / plasma / viridis / cividis） direction = 1) + # 色の順序（-1で逆順） scale_fill_viridis_d(option = &quot;viridis&quot;, # パレットの種類（magma / inferno / plasma / viridis / cividis） direction = 1) # 色の順序（-1で逆順） ggsciカラーパレット（離散型変数） 様々な科学ジャーナルで使用されるカラーパレットです。パレットの種類などの詳細はこちらをご覧ください。 ggplot(data = mpg, mapping = aes(x = fl, color = fl, fill = fl)) + geom_bar() + scale_color_npg() + scale_fill_npg() distillerカラーパレット（連続型変数） RColorBrewerパッケージで提供される様々な種類の美麗なプリセットカラーパレットが利用できます。 # カラーパレットの確認 RColorBrewer::display.brewer.all() ggplot(data = mpg, mapping = aes(x = hwy, fill = ..x..)) + geom_dotplot() + scale_fill_distiller(palette = &quot;Blues&quot;, # カラーパレット名 direction = 1) # 色の順序（-1で逆順） Viridisカラーパレット（連続型変数） 色覚障害に対応したカラーパレットです。パレットの種類などの詳細はこちらを参照してください。 ggplot(data = mpg, mapping = aes(x = hwy, fill = ..x..)) + geom_dotplot() + scale_fill_viridis_c(option = &quot;viridis&quot;, # パレットの種類（magma / inferno / plasma / viridis / cividis） direction = 1) # 色の順序（-1で逆順） gradientカラーパレット（連続型変数） 自分で色を指定してグラデーションを作成するカラーパレットです。2色グラデーション、3色グラデーション、n色グラデーションの3種類の関数があります。n色グラデーションでは、事前にベースとなるカラーパレットをRColorBrewer::display.brewer.all()関数などで確認して使用します。 # 2色グラデーション ggplot(data = mpg, mapping = aes(x = hwy, fill = ..x..)) + geom_dotplot() + scale_fill_gradient(low = &quot;Red&quot;, # 最小値の色 high = &quot;Forestgreen&quot;) # 最大値の色 # 3色グラデーション ggplot(data = mpg, mapping = aes(x = hwy, fill = ..x..)) + geom_dotplot() + scale_fill_gradient2(low = &quot;Red&quot;, # 最小値の色 mid = &quot;Gold&quot;, # 中間値の色 high = &quot;Forestgreen&quot;, # 最大値の色 midpoint = 30) # 中間値 # パレットを指定したn色グラデーション ggplot(data = mpg, mapping = aes(x = hwy, fill = ..x..)) + geom_dotplot() + scale_fill_gradientn(colors = brewer.pal(name = &quot;RdYlGn&quot;, n = 9)) 4.19 軸の設定 X軸、Y軸の設定を行うには、scale_x/y関数ファミリーを使用します。X軸、Y軸に指定する変数の型によって、使用する関数が異なります。 まず、プロット用のデータを作成します。 data_owid_scale &lt;- data_owid %&gt;% dplyr::group_by(location) %&gt;% dplyr::summarise(across(c(new_cases, new_deaths), mean, na.rm = TRUE)) summary(data_owid_scale) ## location new_cases new_deaths ## Length:243 Min. : 0.0 Min. : 0.004 ## Class :character 1st Qu.: 42.8 1st Qu.: 0.497 ## Mode :character Median : 324.8 Median : 4.405 ## Mean : 11619.4 Mean : 141.723 ## 3rd Qu.: 2079.4 3rd Qu.: 24.836 ## Max. :616105.2 Max. :7401.902 ## NA&#39;s :15 NA&#39;s :21 X軸：連続型、Y軸：連続型 ggplot(data = data_owid_scale, mapping = aes(x = new_cases, y = new_deaths)) + geom_point() + geom_smooth() + scale_x_continuous(breaks = breaks_x &lt;- seq(0, 1e+06, 100000), # 目盛 labels = breaks_x, # 目盛ラベル limits = c(0, 7e+05), # 下限・上限値（指定しない場合はNA） expand = expansion(mult = c(0.05, 0.05), add = c(0, 0))) + # 下限・上限値からの余白（multは余白率、addは余白幅） scale_y_continuous(breaks = breaks_y &lt;- seq(0, 10000, 1000), # 目盛 labels = breaks_y, # 目盛ラベル limits = c(0, 8000), # 下限・上限値（指定しない場合はNA） expand = expansion(mult = c(0.05, 0.05), add = c(0, 0))) + # 下限・上限値からの余白（multは余白率、addは余白幅） labs(x = &quot;新規感染者数（1日当たり平均、人）&quot;, # X軸のタイトル y = &quot;新規死亡者数（1日当たり平均、人）&quot;) + # Y軸のタイトル theme(axis.title = element_text(size = 8), # 軸タイトルの文字サイズ axis.text.x = element_text(angle = 0, # X軸ラベルの角度 hjust = 0.5, # X軸ラベルの横整列位置（0-1） vjust = 0.5), # X軸ラベルの縦整列位置（0-1） axis.text.y = element_text(angle = 0, # Y軸ラベルの角度 hjust = 0.5, # Y軸ラベルの横整列位置（0-1） vjust = 0.5)) # Y軸ラベルの縦整列位置（0-1） ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; 対数目盛 ggplot(data = data_owid_scale, mapping = aes(x = new_cases, y = new_deaths)) + geom_point() + geom_smooth() + scale_x_log10(breaks = breaks_x &lt;- 10 ** seq(0, 6, 1), # 目盛 labels = c(breaks_x[1:4], &quot;1万&quot;, &quot;10万&quot;, &quot;100万&quot;), # 目盛ラベル limits = c(1, 7e+05), # 下限・上限値（指定しない場合はNA） expand = expansion(mult = c(0.05, 0.05), add = c(0, 0))) + # 下限・上限値からの余白（multは余白率、addは余白幅） scale_y_log10(breaks = breaks_y &lt;- 10 ** seq(0, 4, 1), # 目盛 labels = c(breaks_y[1:4], &quot;1万&quot;), # 目盛ラベル limits = c(1, 8000), # 下限・上限値（指定しない場合はNA） expand = expansion(mult = c(0.05, 0.05), add = c(0, 0))) + # 下限・上限値からの余白（multは余白率、addは余白幅） labs(x = &quot;新規感染者数（1日当たり平均、人）&quot;, # X軸のタイトル y = &quot;新規死亡者数（1日当たり平均、人）&quot;) + # Y軸のタイトル theme(axis.title = element_text(size = 8), # 軸タイトルの文字サイズ axis.text.x = element_text(angle = 0, # X軸ラベルの角度 hjust = 0.5, # X軸ラベルの横整列位置（0-1） vjust = 0.5), # X軸ラベルの縦整列位置（0-1） axis.text.y = element_text(angle = 0, # Y軸ラベルの角度 hjust = 0.5, # Y軸ラベルの横整列位置（0-1） vjust = 0.5)) # Y軸ラベルの縦整列位置（0-1） ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; X軸：日付型、Y軸：連続型 # date_breaks引数を使用する場合 ggplot(data = economics, mapping = aes(x = date, y = unemploy)) + geom_line() + scale_x_date(date_breaks = &quot;3 month&quot;, # 日付目盛の周期 date_labels = &quot;%y/%b&quot;, # 日付フォーマット（%Y：4桁年、%y：2桁年、%m：2桁月、%b：1桁月、%d：日） limits = c(as.Date(&quot;2000/01/01&quot;), as.Date(&quot;2002/12/31&quot;)), # 始期・終期（指定しない場合はNA） expand = expansion(mult = c(0.00, 0.00), add = c(0, 0))) + # 始期・終期からの余白（multは余白率、addは余白幅） scale_y_continuous(breaks = breaks_y &lt;- seq(0, 50000, 1000), # 目盛 labels = breaks_y, # 目盛ラベル limits = c(5000, 10000), # 下限・上限値（指定しない場合はNA） expand = expansion(mult = c(0.05, 0.05), add = c(0, 0))) + # 下限・上限値からの余白（multは余白率、addは余白幅） labs(x = &quot;日付（年/月）&quot;, # X軸のタイトル y = &quot;失業者数（千人）&quot;) + # Y軸のタイトル theme(axis.title = element_text(size = 8), # 軸タイトルの文字サイズ axis.text.x = element_text(angle = 0, # X軸ラベルの角度 hjust = 0.5, # X軸ラベルの横整列位置（0-1） vjust = 0.5), # X軸ラベルの縦整列位置（0-1） axis.text.y = element_text(angle = 0, # Y軸ラベルの角度 hjust = 0.5, # Y軸ラベルの横整列位置（0-1） vjust = 0.5)) # Y軸ラベルの縦整列位置（0-1） # date_breaks引数を使用しない場合（結果は同じ） ggplot(data = economics, mapping = aes(x = date, y = unemploy)) + geom_line() + scale_x_date(breaks = breaks_x &lt;- seq(as.Date(&quot;1967-01-01&quot;), max(economics$date), by = &quot;3 months&quot;), # 日付目盛ベクトル date_labels = str_c(str_sub(lubridate::year(breaks_x), 3, 4), &quot;/&quot;, lubridate::month(breaks_x)), # 日付目盛ベクトルをラベル用に加工 limits = c(as.Date(&quot;2000/01/01&quot;), as.Date(&quot;2002/12/31&quot;)), # 始期・終期（指定しない場合はNA） expand = expansion(mult = c(0.00, 0.00), add = c(0, 0))) + # 始期・終期からの余白（multは余白率、addは余白幅） scale_y_continuous(breaks = breaks_y &lt;- seq(0, 50000, 1000), # 目盛 labels = breaks_y, # 目盛ラベル limits = c(5000, 10000), # 下限・上限値（指定しない場合はNA） expand = expansion(mult = c(0.05, 0.05), add = c(0, 0))) + # 下限・上限値からの余白（multは余白率、addは余白幅） labs(x = &quot;日付（年/月）&quot;, # X軸のタイトル y = &quot;失業者数（千人）&quot;) + # Y軸のタイトル theme(axis.title = element_text(size = 8), # 軸タイトルの文字サイズ axis.text.x = element_text(angle = 0, # X軸ラベルの角度 hjust = 0.5, # X軸ラベルの横整列位置（0-1） vjust = 0.5), # X軸ラベルの縦整列位置（0-1） axis.text.y = element_text(angle = 0, # Y軸ラベルの角度 hjust = 0.5, # Y軸ラベルの横整列位置（0-1） vjust = 0.5)) # Y軸ラベルの縦整列位置（0-1） 4.20 複数グラフ（ファセット） 複数のグラフをまとめたファセットを作成するには、facet関数ファミリーを使用します。どのようなファセットにするかで使用する関数が異なります。 行方向の複合グラフ 行方向に複合グラフを並べる場合は、facet_rep_grid()関数のrows引数にvars(離散型変数)の形でグラフを分けて作成したい変数名を指定します。 ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) + geom_point() + facet_rep_grid(rows = vars(class), # 変数class別にグラフを作成 scales = &quot;fixed&quot;, # 目盛設定（fixed：全グラフ共通、free：全グラフ独立、free_x：X軸のみ独立、free_y：Y軸のみ独立） repeat.tick.labels = FALSE) # 目盛表示（TRUE：すべてのグラフに表示、FALSE：端のグラフのみ表示 列方向の複合グラフ 列方向に複合グラフを並べる場合は、facet_rep_grid()関数のcols引数にvars(離散型変数)の形でグラフを分けて作成したい変数名を指定します。 ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) + geom_point() + facet_rep_grid(cols = vars(class), # 変数class別にグラフを作成 scales = &quot;fixed&quot;, # 目盛設定（fixed：全グラフ共通、free：全グラフ独立、free_x：X軸のみ独立、free_y：Y軸のみ独立） repeat.tick.labels = FALSE) # 目盛表示（TRUE：すべてのグラフに表示、FALSE：端のグラフのみ表示 行・列方向の複合グラフ 行・列方向に複合グラフを並べる場合は、facet_rep_grid()関数のrows引数とcols引数にそれぞれvars(離散型変数)の形でグラフを分けて作成したい変数名を指定します。 ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) + geom_point() + facet_rep_grid(rows = vars(year), # 変数year別に行方向のグラフを作成 cols = vars(class), # 変数class別に列方向のグラフを作成 scales = &quot;fixed&quot;, # 目盛設定（fixed：全グラフ共通、free：全グラフ独立、free_x：X軸のみ独立、free_y：Y軸のみ独立） repeat.tick.labels = TRUE) # 目盛表示（TRUE：すべてのグラフに表示、FALSE：端のグラフのみ表示 行数・列数を指定した複合グラフ 行数と列数を指定してグラフを順番に並べるには、facet_rep_wrap()関数のfacets引数に~ 離散型変数の形でグラフを分けて作成したい変数名を指定し、nrow引数とncol引数に行数・列数を指定します。 ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) + geom_point() + facet_rep_wrap(facets = ~ manufacturer, # 変数manufacturer別にグラフを作成 nrow = 3, # 行方向のグラフ数 ncol = 5, # 列方向のグラフ数 scales = &quot;fixed&quot;, # 目盛設定（fixed：全グラフ共通、free：全グラフ独立、free_x：X軸のみ独立、free_y：Y軸のみ独立） repeat.tick.labels = TRUE) # 目盛表示（TRUE：すべてのグラフに表示、FALSE：端のグラフのみ表示 複合グラフの設定 ファセットの各種設定を行うには、theme()関数内に必要事項を記入します。 # 行数・列数を指定した複合グラフの例 ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) + geom_point() + facet_rep_wrap(facets = ~ manufacturer) + # 変数manufacturer別にグラフを作成 theme(strip.background = element_rect(color = NA, # ファセットタイトル領域の枠の色 fill = &quot;White&quot;), # ファセットタイトル領域の塗りつぶしの色（NAで無色） strip.text = element_text(color = &quot;Black&quot;, # ファセットタイトルの色 face = &quot;bold&quot;, # ファセットタイトルの書体 size = 8, # ファセットタイトルのフォントサイズ hjust = 0.5, # ファセットタイトルの横方向の整列位置 vjust = 0.5), # ファセットタイトルの縦方向の整列位置 panel.spacing.x = unit(x = 2, units = &quot;mm&quot;), # ファセットのグラフ間の横方向のスペース panel.spacing.y = unit(x = 2, units = &quot;mm&quot;)) # ファセットのグラフ間の縦方向のスペース 4.21 地図ファセット 国別・州別・都道府県別のデータを、地図を模した複合グラフに表示するには、geofacetパッケージのfacet_geo()関数を使用します。 ここでは、日本の県内総生産データを使用します。 data_gdp_pref ## # A tibble: 611 x 5 ## pref_code pref_name year gdp_nominal gdp_nominal_pchg ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 北海道 2006 19316568 NA ## 2 1 北海道 2007 19137599 -0.927 ## 3 1 北海道 2008 18457858 -3.55 ## 4 1 北海道 2009 18219113 -1.29 ## 5 1 北海道 2010 18122675 -0.529 ## 6 1 北海道 2011 18071493 -0.282 ## 7 1 北海道 2012 17923502 -0.819 ## 8 1 北海道 2013 18242119 1.78 ## 9 1 北海道 2014 18579766 1.85 ## 10 1 北海道 2015 19128504 2.95 ## # ... with 601 more rows geofacetパッケージでは、都道府県名と地図上の位置を結びつけるjp_prefs_grid2データが用意されています。ただし都道府県名が英語表記でしか格納されていないため、日本語表記を名寄せして追加します。 # geofacetのjp_prefs_grid2に都道府県名の日本語表記を追加 data_prefs &lt;- data_gdp_pref %&gt;% dplyr::select(pref_code, pref_name) %&gt;% dplyr::distinct() %&gt;% dplyr::rename(code = pref_code) jp_prefs_grid2 %&lt;&gt;% dplyr::left_join(data_prefs, by = &quot;code&quot;) そのうえで、ファセット部分にfacet_geo()関数を用いると、都道府県別のデータを日本地図を模した形でグラフ化することができます。 ggplot(data = data_gdp_pref, mapping = aes(x = year, y = gdp_nominal_pchg)) + geom_line() + geom_point() + facet_geo(facets = ~ pref_name, # 変数pref_name別にグラフを作成 grid = &quot;jp_prefs_grid2&quot;, # 使用する地図グリッド scales = &quot;fixed&quot;) + # 目盛設定（fixed：全グラフ共通、free：全グラフ独立、free_x：X軸のみ独立、free_y：Y軸のみ独立） theme(strip.background = element_rect(color = NA, # ファセットタイトル領域の枠の色 fill = NA), # ファセットタイトル領域の塗りつぶしの色（NAで無色） strip.text = element_text(color = &quot;Black&quot;, # ファセットタイトルの色 face = &quot;bold&quot;, # ファセットタイトルの書体 size = 8, # ファセットタイトルのフォントサイズ hjust = 0.5, # ファセットタイトルの横方向の整列位置 vjust = 0.5), # ファセットタイトルの縦方向の整列位置 panel.spacing.x = unit(x = 1, units = &quot;mm&quot;), # ファセットのグラフ間の横方向のスペース panel.spacing.y = unit(x = 0.5, units = &quot;mm&quot;)) # ファセットのグラフ間の縦方向のスペース 4.22 その他設定・保存 タイトル、目盛線、凡例、図表全体のフォント、マージンなどの各種設定を行います。 タイトル・キャプション ggplot(data = mpg, mapping = aes(x = cty, y = hwy, fill = class)) + geom_point(shape = 21, size = 2.0) + labs(title = &quot;車体クラス別の一般道燃費と高速道燃費&quot;, # 図表タイトル caption = &quot;（出所）EPA.gov&quot;, # キャプション fill = &quot;車体クラス&quot;) + # 凡例に使用するscaleのタイトル theme(plot.title = element_text(size = 10, # 図表タイトルの文字サイズ face = &quot;bold&quot;, # 図表タイトルの書体 hjust = 0.5), # 図表タイトルの横整列位置 plot.caption = element_text(size = 8, # キャプションの文字サイズ face = &quot;plain&quot;, # キャプションの書体 hjust = 0.0)) # キャプションの横整列位置 パネル目盛線 ggplot(data = mpg, mapping = aes(x = cty, y = hwy, fill = class)) + geom_point(shape = 21, size = 2.0) + theme(panel.grid.major = element_line(color = &quot;grey&quot;, # 主目盛線の色 linetype = &quot;dashed&quot;, # 主目盛線の種類（solid / dashed / dotted / dotdash / twodash / longdash） size = 0.2), # 主目盛線の太さ panel.grid.minor = element_blank()) # 補助目盛り線は表示しない 凡例 ggplot(data = mpg, mapping = aes(x = cty, y = hwy, fill = class)) + geom_point(shape = 21, size = 2.0) + theme(legend.title = element_text(size = 8, # 凡例タイトルの文字サイズ face = &quot;bold&quot;, # 凡例タイトルの書体 hjust = 0.0), # 凡例タイトルの横整列位置 legend.text = element_text(size = 6), # 凡例ラベルの文字サイズ legend.box.background = element_rect(color = &quot;grey&quot;, # 凡例の枠線の色 size = 0.5), # 凡例の枠線の太さ legend.margin = margin(t = 1, # 凡例の上マージン b = 1, # 凡例の下マージン r = 1, # 凡例の右マージン l = 1, # 凡例の左マージン unit = &quot;mm&quot;), # 凡例マージンの単位 legend.justification = c(1.0, 0.0), # 凡例の横整列位置・縦整列位置 legend.position = c(0.95, 0.05)) + # 凡例の横位置・縦位置 guides(fill = guide_legend(keywidth = unit(3, units = &quot;mm&quot;), # 凡例キーの幅 keyheight = unit(3, units = &quot;mm&quot;), # 凡例キーの高さ direction = &quot;vertical&quot;, # 凡例の整列方向（horizontal / vertical） nrow = 3, # 凡例の行数 ncol = 3, # 凡例の列数 reverse = FALSE)) # 凡例順序の逆転 フォント・マージン設定 ggplot(data = mpg, mapping = aes(x = cty, y = hwy, fill = class)) + geom_point(shape = 21, size = 2.0) + theme(text = element_text(family = &quot;YUGO&quot;, # 図表全体のフォント size = 8), # 図表全体の無事サイズ plot.margin = margin(t = 1, # 図表の上マージン b = 1, # 図表の下マージン r = 1, # 図表の右マージン l = 1, # 図表の左マージン unit = &quot;mm&quot;)) # 図表マージンの単位 保存 ggplot2パッケージで作成した図表を画像形式で保存するには、ggsave()関数を使用します。 ggsave(filename = &quot;directory/filename.png&quot;, # 図表のファイル名 width = 12.00, # 図表の横サイズ height = 9.00, # 図表の縦サイズ units = &quot;cm&quot;, # 図表のサイズ単位 dpi = 300) # 図表の解像度 4.23 実例 実例1：世界の新型コロナ死亡率の箱ひげ図 # プロット用のデータの作成 data_plot &lt;- data_owid %&gt;% dplyr::select(location, date, new_cases, new_deaths) %&gt;% dplyr::filter(date &lt;= max(date) - 28) %&gt;% dplyr::mutate(year = lubridate::year(date)) %&gt;% dplyr::group_by(location, year) %&gt;% dplyr::summarise(across(c(new_cases, new_deaths), mean, na.rm = TRUE)) %&gt;% dplyr::mutate(mort_rate = 100 * new_deaths / new_cases, year = str_c(year, &quot;年&quot;)) # プロット ggplot(data = data_plot, mapping = aes(x = year, y = mort_rate, color = year, fill = year)) + geom_hline(yintercept = 0, # 水平線の縦軸との交点 color = &quot;gray&quot;, # 水平線の色 size = 0.5) + # 水平線の太さ geom_boxplot(outlier.shape = NA, alpha = 0.25, size = 0.5) + geom_jitter(alpha = 0.5, size = 1.0, shape = 21) + scale_y_continuous(breaks = breaks_y &lt;- seq(0, 100, 0.5), # 目盛 labels = breaks_y %&gt;% sprintf(fmt = &quot;%0.1f&quot;), # 目盛ラベル limits = c(0, 5), # 下限・上限値（指定しない場合はNA） expand = expansion(mult = c(0.05, 0.05), add = c(0, 0))) + # 下限・上限値からの余白（multは余白率、addは余白幅） labs(x = element_blank(), # X軸のタイトル y = &quot;新型コロナ感染者の致死率（％）&quot;) + # Y軸のタイトル theme(axis.title = element_text(size = 8)) + # 軸タイトルの文字サイズ labs(title = &quot;世界各国の新型コロナ感染者の致死率（年別）&quot;, # 図表タイトル caption = &quot;（注）箱の中の横線は中央値を示す。2022年は直近4週間のサンプルを除外。\\n（出所）Our World in Data、@naohat23&quot;) + # キャプション theme(plot.title = element_text(size = 10, # 図表タイトルの文字サイズ face = &quot;bold&quot;, # 図表タイトルの書体 hjust = 0.5), # 図表タイトルの横整列位置 plot.caption = element_text(size = 8, # キャプションの文字サイズ face = &quot;plain&quot;, # キャプションの書体 hjust = 0.0)) + # キャプションの横整列位置 theme(panel.grid.major = element_line(color = &quot;grey&quot;, # 主目盛線の色 linetype = &quot;dashed&quot;, # 主目盛線の種類（solid / dashed / dotted / dotdash / twodash / longdash） size = 0.2), # 主目盛線の太さ panel.grid.minor = element_blank()) + # 補助目盛り線は表示しない theme(legend.position = &quot;none&quot;) + # 凡例の横位置・縦位置 theme(text = element_text(family = &quot;YUGO&quot;, # 図表全体のフォント size = 8), # 図表全体の無事サイズ plot.margin = margin(t = 1, # 図表の上マージン b = 1, # 図表の下マージン r = 1, # 図表の右マージン l = 1, # 図表の左マージン unit = &quot;mm&quot;)) # 図表マージンの単位 保存 ggsave(filename = &quot;directory/filename.png&quot;, # 図表のファイル名 width = 12.00, # 図表の横サイズ height = 9.00, # 図表の縦サイズ units = &quot;cm&quot;, # 図表のサイズ単位 dpi = 600) # 図表の解像度 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
