# tidyverseによるデータ操作

第3章「tidyverseによるデータ操作」では、`tidyverse`の`dplyr`パッケージと`tidyr`パッケージを使用した効率的なデータ操作のコードについて解説します。

## パッケージのインポート

```{r, results='hide', warning=FALSE, message=FALSE}
library(magrittr)
library(tidyverse)
library(tidyquant)
```

## tidyverseとは

`tidyverse`は、Rでデータを効率的に操作・可視化するために開発された様々なパッケージをひとまとめにしたものです。本節では、データ操作に関わる`dplyr`パッケージと`tidyr`パッケージを主に使用します。

-   `dplyr`：データセットに様々な操作を加えるパッケージ
-   `tidyr`：データセットをtidy dataに変形するためのパッケージ

**tidy data**とは、`tidyverse`の開発者であるHadley Wickham氏が提唱した概念で、機械処理しやすいデータ形式のことを言います。具体的には、以下の条件を満たすデータをtidy dataと定義します。

-   1つの列が1つの変数を表す
-   1つの行が1つのレコードを表す
-   1つのテーブルが1つのデータセットだけを含む

例えば、国別・産業別GDPの時系列データであれば、国の列、産業の列、時点の列、データ（GDP）の列、の4列で構成されるデータがtidy dataです。こうしたデータを縦型データとも呼びます。

これに対して、国や産業が横方向に並んでいる場合（日本・製造業のGDPの列、日本・飲食業のGDPの列、米国・金融業のGDPの列...など）は、tidy data（縦型データ）ではなく、横型データと呼ばれます。

tidy dataは属性条件によるフィルタがかけやすいなど、データ処理が列方向に一括して行えるため、機械処理に適しています。

tidy dataの詳細については、[松村優哉、湯谷啓明、紀ノ定保礼、前田和寛（2021）『改訂2版 Rユーザのための RStudio［実践］入門』](https://gihyo.jp/book/2021/978-4-297-12170-9)を参照してください。

`dplyr`パッケージや`tidyr`パッケージの関数は、もとのデータセットに対して変更を一切加えません。データセットを操作した結果を残しておくためには、結果をオブジェクトに代入する必要があります。なお、代入先をもとのデータセットのオブジェクトにすると、データセットの内容が書き換えられます。

`tidyverse`ではパイプ`%>%`が多用されます。パイプは、データセットに対して適用した関数の結果を、次の関数へと受け渡すものです。パイプを連続して使用することで、処理の途中の結果をいちいちオブジェクトに代入することなく、一括して複数の処理を行うことができます。

以下はmpgデータセットに対する複数の関数の処理をパイプでつなげたものです。

```{r}
# mpgデータセットからmanufacturer列とcty列を選択し、manufacturer列でフィルタしたうえで、
# cty列を10倍し、結果をresultオブジェクトに保存する例
result <- mpg %>% 
  dplyr::select(manufacturer, cty) %>% 
  dplyr::filter(manufacturer == "toyota") %>% 
  dplyr::mutate(cty_10 = cty * 10)

print(result)
```

## サンプルデータの読み込み

本節で使用するサンプルデータをWebから直接読み込みます。プロキシ環境では、プロキシサーバーの設定が必要です。

```{r, eval=FALSE}
## プロキシサーバーとポートを記入
proxy_url <- "http://proxyserver:port/"


## Rのシステム環境変数を設定
Sys.setenv("http_proxy" = proxy_url)
Sys.setenv("https_proxy" = proxy_url)


## Rのダウンロードオプションを設定
options(download.file.method = "libcurl")
options(timeout = NA)
```

ここでは、Our World in Dataの新型コロナウイルス関連データセットを使用します。データの詳細は[こちら](https://ourworldindata.org/coronavirus)を参照してください。

Hannah Ritchie, Edouard Mathieu, Lucas Rodés-Guirao, Cameron Appel, Charlie Giattino, Esteban Ortiz-Ospina, Joe Hasell, Bobbie Macdonald, Diana Beltekian and Max Roser (2020) - "Coronavirus Pandemic (COVID-19)". Published online at OurWorldInData.org. Retrieved from: '<https://ourworldindata.org/coronavirus>' [Online Resource]

```{r, warning=FALSE, message=FALSE}
# Our World in Dataの新型コロナデータをtibble型で読み込み
data_owid <- readr::read_csv(file = "https://covid.ourworldindata.org/data/owid-covid-data.csv", # ファイルパス／URL
                             col_names = TRUE, # ヘッダー（列名データ）の有無
                             col_types = NULL, # 各列の型の指定（c：文字列型、d：数値型、D：日付型、l：論理値型）
                             skip = 0) # 読み込み時に上からスキップする行数

# 使用するデータを絞り込み
data_owid %<>% 
  dplyr::select(continent, location, date, 
                total_cases, new_cases, total_deaths, new_deaths, 
                total_cases_per_million, new_cases_per_million, total_deaths_per_million, new_deaths_per_million,
                people_fully_vaccinated) %>% 
  dplyr::filter(location %in% c("Japan", "United States", "United Kingdom", "Germany"))

# データをコンソールに出力
data_owid
```

## 列の選択

データセットから列（変数）を選択するには、`dplyr::select()`関数を使用します。

### 列名で選択 {.unnumbered}

```{r}
data_owid %>% 
  dplyr::select(location, date, new_cases)
```

### 列名を格納したベクトルで選択 {.unnumbered}

```{r}
cols <- c("location", "date", "new_cases")
data_owid %>% 
  dplyr::select(cols) 
```

### 列を非選択（削除） {.unnumbered}

```{r}
data_owid %>% 
  dplyr::select(-location) 
```

### 列名に特定の文字列を含む列を選択 {.unnumbered}

```{r}
data_owid %>% 
  dplyr::select(location, date, contains("cases"))
```

### 列名が特定の文字列から始まる列を選択 {.unnumbered}

```{r}
data_owid %>% 
  dplyr::select(location, date, starts_with("new_cases")) 
```

### 列名が特定の文字列で終わる列を選択 {.unnumbered}

```{r}
data_owid %>% 
  dplyr::select(location, date, ends_with(c("cases", "deaths"))) 
```

### 特定の型の列を選択 {.unnumbered}

```{r}
data_owid %>% 
  dplyr::select(where(is.character) | where(is.Date)) 
```

## 列名の変更

データセットの列名（変数名）を変更するときは、`dplyr::rename()`関数を使用します。

```{r}
data_owid %>% 
  dplyr::rename(country = location)
```

## 行のフィルタ

データセットの行のフィルタ（特定の条件を満たすデータの抽出）を行うには、`dpoyr::filter()`関数を使用します。

### 条件に一致する行 {.unnumbered}

```{r}
data_owid %>% dplyr::filter(location == "Japan")
```

### 条件に一致しない行（NOT条件） {.unnumbered}

NOT条件は`!=`演算子を使用します。

```{r}
data_owid %>% dplyr::filter(continent != "Asia")
```

### 複数条件 {.unnumbered}

`dplyr::filter()`関数内で複数条件を指定すると、左から順番に条件が適用されます。

```{r}
data_owid %>% dplyr::filter(location == "Japan", date >= "2021-01-01", date <= "2021-01-07")
```

### AND・OR条件を明示的に指定した複数条件 {.unnumbered}

左から順番に条件を適用しないためには、`&`演算子と`|`演算子で明示的にAND条件とOR条件を指定します。

```{r}
data_owid %>% dplyr::filter((date == "2022-01-01") & (location == "Japan" | location == "United States"))
```

### `%in%`演算子によるOR条件 {.unnumbered}

複数の値が格納されたベクトルと`%in%`演算子を用いて、OR条件で行をフィルタします。この場合は、日本と米国のレコードを抽出しています。

```{r}
locations <- c("Japan", "United States")

data_owid %>% dplyr::filter(location %in% locations, date == "2021-01-01")
```

### OR条件の否定 {.unnumbered}

`%in%`演算子によるOR条件を`!`で否定します。この場合は、日本・米国以外を抽出しています。

```{r}
data_owid %>% dplyr::filter(!location %in% locations, date == "2021-01-01")
```

### 関数による条件指定 {.unnumbered}

```{r}
data_owid %>% dplyr::filter(date == max(date))
```

### 論理値を返す関数による条件指定 {.unnumbered}

`is.na()`関数のように倫理値を返す関数は、`==`演算子がなくてもフィルタ条件として使用することができます。

```{r}
data_owid %>% dplyr::filter(is.na(new_cases))
```

## 行の並べ替え

データセットの行を並べ替えるには、`dplyr::arrange()`関数を使用します。

### 昇順ソート {.unnumbered}

```{r}
data_owid %>% 
  dplyr::arrange(new_cases) 
```

### 降順ソート {.unnumbered}

```{r}
data_owid %>% 
  dplyr::arrange(-new_cases) 
```

### 降順ソート（日付型） {.unnumbered}

日付型のデータは`-`演算子で降順ソートができないため、`desc()`関数を使用します。

```{r}
data_owid %>% 
  dplyr::arrange(desc(date)) 
```

### 複数条件によるソート {.unnumbered}

`dplyr::arrange()`関数内で複数条件を指定すると、左から順番に適用します。

```{r}
data_owid %>% 
  dplyr::arrange(desc(date), -new_cases) 
```

## 列の追加・修正

データセットの列を追加・修正するには、`dplyr::mutate()`関数を使用します。

まず、使用するサンプルデータを作成します。

```{r}
data_owid_jp <- data_owid %>% 
  dplyr::select(location, date, new_cases, new_deaths) %>% 
  dplyr::filter(location == "Japan",
                date >= "2022-01-01")
```

### 新たな列の作成 {.unnumbered}

既存の列（変数）の計算結果として、新たな列を追加します。`=`演算子の左側が新たに作成する列名、右側が計算式です。作成する際、`.before`引数もしくは`.after`引数に既存の列名を指定すると、指定した列の前後に新たな列を挿入します。`.before`引数、`.after`引数を指定しなければ、新たな列は最右列に追加されます。

```{r}
data_owid_jp %>% 
  dplyr::mutate(death_rate = new_deaths / new_cases,
                .after = "date") 
```

### 既存の列の修正 {.unnumbered}

`=`演算子の左側に既存の列名を指定すると、当該列を修正します。

```{r}
data_owid %>% 
  dplyr::mutate(location = factor(location))
```

### ラグ・リード系列の作成 {.unnumbered}

`dplyr::lag()`関数と`dplyr::leag()`関数で、既存の列のラグ・リード系列を作成します。

```{r}
# 1期ラグの系列を追加
data_owid_jp %>% 
  dplyr::mutate(new_cases_lag = dplyr::lag(new_cases, n = 1)) 
```

### 変化率系列の作成 {.unnumbered}

`dplyr::lag()`関数で、既存の列の変化率系列を作成します。

```{r}
# 前期比変化率（％表示）の系列を追加
data_owid_jp %>% 
  dplyr::mutate(new_cases_chg = 100 * (new_cases / dplyr::lag(new_cases, n = 1) - 1)) 
```

### 移動平均系列の作成 {.unnumbered}

`zoo::rollmean()`関数で、移動平均系列を作成します。

```{r}
# 後方7日移動平均の系列を追加
data_owid_jp %>% 
  dplyr::mutate(new_cases_7dma = zoo::rollmean(new_cases, # 移動平均を作成するもとの系列名
                                               k = 7, # 移動平均の期間
                                               na.pad = TRUE, # 系列の先端部分で移動平均を計算できない箇所をNAで埋めるか
                                               align = "right")) # left：前方移動平均、center：中央移動平均、right：後方移動平均
```

### 条件付き系列の作成 {.unnumbered}

`dplyr::case_when()`関数の中に、`既存の系列を用いた条件 ~ 条件を満たす場合にとる値`の形で条件式を書き、新たな系列を作成します。複数条件を指定した場合、左から順番に条件が適用されます。「その他すべて」の条件は`TRUE`で指定します。

```{r}
# 単一条件を指定してダミー変数を作成
data_owid_jp %>% 
  dplyr::mutate(dummy = dplyr::case_when(new_cases < 3000 ~ 1,
                                         TRUE ~ 0))

# 複数条件を指定
data_owid_jp %>% 
  dplyr::mutate(case = dplyr::case_when(new_cases < 1000 ~ "A",
                                        (new_cases >= 5000 & new_cases < 8000) ~ "B",
                                        TRUE ~ "other"))
```

### 複数列の一括処理 {.unnumbered}

`dplyr::mutate()`関数内で`across()`関数を用い、対象の列と処理方法を指定して一括処理します。`~ {}`は無名関数（ラムダ式）を表し、波括弧の中のドットはチルダの左側の値を代入することを意味します。

```{r}
# new_casesからnew_deathまでのすべての列を1000で除す
data_owid_jp %>% 
  dplyr::mutate(across(new_cases:new_deaths, ~ {. / 1000}))

# new_casesからnew_deathまでのすべての列の前期比変化率を計算
data_owid_jp %>% 
  dplyr::mutate(across(new_cases:new_deaths, ~ {. / dplyr::lag(., n = 1)})) 
```

## グループ化

データセットを属性ごとにグループ化するには、`dplyr::group_by()`関数を使用します。グループ化するだけでは変化はありませんが、`dplyr::filter()`関数や、次の`dplyr::summarise()`関数とあわせて使用することで、より柔軟なデータセット操作が可能になります。

### 単一の列でグループ化 {.unnumbered}

見た目は変わりませんが、データを`print()`関数で出力するとデータの属性を示す冒頭箇所の2行目にGroupsが追加されています。

```{r}

data_owid %>% 
  dplyr::group_by(location) %>% 
  print()
```

### 複数の列でグループ化 {.unnumbered}

```{r}
data_owid %>%
  dplyr::group_by(continent, location) %>% 
  print()
```

### グループ化＆フィルタ {.unnumbered}

グループ化と行のフィルタを組み合わせて、グループ別にフィルタを適用します。ここでは、グループ別の最大値を抽出しています。

```{r}
data_owid %>% 
  dplyr::group_by(location) %>% 
  dplyr::filter(new_cases == max(new_cases, na.rm = TRUE))
```

### グループ化の解除 {.unnumbered}

`dplyr::ungroup()`関数でグループ化を解除します。グループ化の有無でフィルタや集計の結果が変わるため、思わぬ事故を防ぐためにも、所定の結果を得た後はグループ化を解除しておくことを推奨します。

```{r}
data_owid %>% 
  dplyr::group_by(location) %>% 
  dplyr::ungroup()
```

## 集計

グループ化したデータセットに対して`dplyr::summarise()`関数を使用すると、グループ別に集計操作を行うことができます。

### グループ別の集計 {.unnumbered}

```{r}
# 指定した列のグループ別の平均値を計算
data_owid %>% 
  dplyr::group_by(location) %>% 
  dplyr::summarise(new_cases_mean = mean(new_cases, na.rm = TRUE))

# 指定した列のグループ別の最大値を計算
data_owid %>% 
  dplyr::group_by(location) %>% 
  dplyr::summarise(new_cases_max = max(new_cases, na.rm = TRUE))
```

### クロス集計 {.unnumbered}

`dplyr::group_by()`関数で複数条件を指定してグループ化すると、クロス集計を行うことができます。

```{r}
data_owid %>% 
  dplyr::group_by(location, lubridate::year(date)) %>% 
  dplyr::summarise(new_cases_mean = mean(new_cases, na.rm = TRUE))
```

### 複数列の一括処理 {.unnumbered}

`dplyr::summarise()`関数内で`across()`関数を用い、対象の列と処理方法を指定して一括処理します。

```{r}
# new_casesとnew_deathsの列について、グループ別の合計値を計算
data_owid %>% 
  dplyr::group_by(location) %>% 
  dplyr::summarise(across(c(new_cases, new_deaths), sum, na.rm = TRUE)) 

# 列名がcasesで終わる列すべてについて、グループ別の合計値を計算
# 列名per_millionで終わる列すべてについて、グループ別の平均値を計算
data_owid %>% 
  dplyr::group_by(location) %>% 
  dplyr::summarise(across(ends_with("cases"), sum, na.rm = TRUE),
                   across(ends_with("per_million"), mean, na.rm = TRUE))

# 数値型の列すべてについて、グループ別の平均値を計算
data_owid %>% 
  dplyr::group_by(location) %>% 
  dplyr::summarise(across(is.double, mean, na.rm = TRUE))
```

## 縦型・横型の変換

`tidyr`パッケージの`pivot_longer()`関数と`pivot_wider()`関数を使用して、縦型データ（tidy data）と横型データの変換を行います。縦型データは、`ggplot2`パッケージによるグラフ作成で多用します。

まず、使用するサンプルデータを作成します。

```{r}
data_owid_cases <- data_owid %>% 
  dplyr::select(location, date, new_cases) %>% 
  dplyr::filter(date >= "2021-01-01") %>% 
  dplyr::arrange(date)

data_owid_cases
```

### 縦型データを横型データに変換 {.unnumbered}

```{r}
data_owid_cases_wide <- data_owid_cases %>% 
  tidyr::pivot_wider(id_cols = "date", names_from = "location", values_from = "new_cases") 

data_owid_cases_wide
```

### 横型データを縦型データに変換 {.unnumbered}

```{r}
data_owid_cases_long <- data_owid_cases_wide %>% 
  tidyr::pivot_longer(cols = -"date", names_to = "location", values_to = "new_cases") 

data_owid_cases_long
```

## データの結合

複数のデータセットのオブジェクトを結合して一つのデータセットにするには、`dplyr`パッケージの`join()`関数ファミリーを使用します。`join()`関数は、結合方法によって4種類に分かれています。

まず、使用するサンプルデータを確認します。

```{r}
band_members
band_instruments
```

### 内部結合 {.unnumbered}

`dplyr::inner_join()`関数は、両方のデータに共通して存在する行のみ結合し、その他の行は削除します。

```{r}
dplyr::inner_join(band_members, band_instruments, by = "name")
```

### 左外部結合 {.unnumbered}

`dplyr::left_join()`関数は、左側のデータに存在する行のみ結合し、その他の行は削除します。

```{r}
dplyr::left_join(band_members, band_instruments, by = "name")
```

### 右外部結合 {.unnumbered}

`dplyr::right_join()`関数は、右側のデータに存在する行のみ結合し、その他の行は削除します。

```{r}
dplyr::right_join(band_members, band_instruments, by = "name")
```

### 完全外部結合 {.unnumbered}

`dplyr::full_join()`関数は、両方のデータのすべての行を結合し、行を削除しません。

```{r}
dplyr::full_join(band_members, band_instruments, by = "name")
```

## 重複処理

### 重複業の抽出

重複している行を抽出するには、`dplyr::group_by()`関数、`dplyr::filter()`関数、`dplyr::n()`関数を組み合わせて使用します。`dplyr::n()`関数は、`dplyr::group_by()`関数で指定したグループのサイズを返す関数です。

```{r}
# 指定した列を対象にして、重複している行を抽出
mpg %>% 
  dplyr::group_by(manufacturer, model, displ, year, cyl, trans, cty, hwy) %>% 
  dplyr::filter(dplyr::n() > 1)
```


### 重複行の削除 {-}

重複している行を削除するには、`dplyr::distinct()`関数を使用します。

```{r}
# すべての列を対象にして、重複している行を削除
data_owid %>% 
  dplyr::distinct()

# 指定した列を対象にして、重複している行を削除
data_owid %>% 
  dplyr::distinct(continent, location)
```

## 欠損値処理

欠損値（NA）がある行を削除したり、NAのレコードを他の値で置き換えたりするには、`tidyr`パッケージの`drop_na()`関数、`replace_na()`関数、`fill()`関数を使用します。

まず、使用するサンプルデータを作成します。

```{r}
data_owid_vaccinated <- data_owid %>% 
  dplyr::select(location, date, people_fully_vaccinated) %>% 
  dplyr::filter(location %in% c("Japan", "United States", "United Kingdom"),
                date >= "2021-01-01") %>% 
  dplyr::arrange(date) %>% 
  tidyr::pivot_wider(id_cols = "date", names_from = "location", values_from = "people_fully_vaccinated")

tail(data_owid_vaccinated)
```

### NAの削除 {.unnumbered}

特定の列を対象にして、NAが含まれている行を削除するには、`tidyr::drop_na()`関数で列名を指定します。

```{r}
data_owid_vaccinated %>% 
  tidyr::drop_na(Japan) %>%  
  tail()
```

すべての列を対象にして、NAが含まれている行を削除するには、`tidyr::drop_na()`関数の中で`everything()`関数を使用します。

```{r}
data_owid_vaccinated %>% 
  tidyr::drop_na(everything()) %>%  
  tail()
```

### NAの置換 {.unnumbered}

特定の列のNAを別の値に置き換えるには、`tidyr::replace_na()`関数で列名と置換する値を指定します。

```{r}
data_owid_vaccinated %>% 
  dplyr::mutate(Japan = tidyr::replace_na(data = Japan, replace = 0)) %>%  
  tail()
```

NAを他の値に置き換える列が複数ある場合は、`dplyr::mutate_at()`関数で列名を複数指定して一括処理します。

```{r}
data_owid_vaccinated %>% 
  dplyr::mutate_at(vars(-date), tidyr::replace_na, replace = 0) %>% 
  tail()
```

### NAのフィル {.unnumbered}

特定の列のNAを同じ列の前後の値でフィルするには、`tidyr::fill()`関数で列名を指定します。`.direction`引数が`"down"`なら上の値でフィル、`"up"`なら下の値でフィルします。

```{r}
data_owid_vaccinated %>% 
  tidyr::fill(Japan, .direction = "down") %>% 
  tail()
```

すべての列のNAの値をフィルする場合は、`tidyr::fill()`関数の中で`everything()`関数を使用します。

```{r}
data_owid_vaccinated %>% 
  tidyr::fill(c(-date, everything()), .direction = "down") %>% 
  tail()
```

## 補完処理

データセットが特定の属性の組み合わせのレコード（行）を欠いている場合や、時系列データで特定の時点のレコード（行）が含まれていない場合は、`tidyr::complete()`関数で補完することができます。

まず、使用するサンプルデータを作成します。

```{r}
# サンプルデータ1
data_complete_1 <- tibble(
  group = c(1:2, 1, 2),
  item_id = c(1:2, 2, 3),
  item_name = c("a", "a", "b", "b"),
  value1 = c(1, NA, 3, 4),
  value2 = 4:7
)

data_complete_1
```

```{r}
# サンプルデータ2
data_complete_2 <- tibble(
  date = as.Date(c("2022-01-01", "2022-01-03", "2022-01-04")),
  value = c(11, 13, 14)
)

data_complete_2
```

### 組み合わせ候補の補完 {.unnumbered}

`tidyr::complete()`関数の中で列名を指定し、当該変数のすべての組み合わせ候補を補完します。補完した行の値はNAになります。

```{r}
data_complete_1 %>% 
  tidyr::complete(group, item_id, item_name)
```

`tidyr::nesting()`関数に複数の列名を指定すると、それらの列について実現値のユニークな組み合わせをあらかじめ求め、それと別の列とのすべての組み合わせ候補を補完します。

```{r}
data_complete_1 %>% 
  tidyr::complete(group, tidyr::nesting(item_id, item_name))
```

### 時系列データの補完 {.unnumbered}

時系列データの欠損期間を補完するには、`full_seq()`関数を使用します。

```{r}
# 日次データの欠損日を補完
data_complete_2 %>% 
  tidyr::complete(date = full_seq(date, period = 1))
```

## サンプリング

データセットからデータをサンプリングするには、`dplyr::sample`関数ファミリーを使用します。ここでは、53940サンプルあるdiamondsデータセットからサンプリングを行います。

```{r}
diamonds
```

サンプル数を決めてサンプリングするには、`dplyr::sample_n()`関数を使用します。

```{r}
diamonds %>% 
  dplyr::sample_n(size = 1000)
```

サンプル数をオリジナルデータセットのサンプル数の比率で決定する場合は、`dplyr::sample_frac()`関数を使用します。

```{r}
diamonds %>% 
  dplyr::sample_frac(size = 0.1)
```

## 時系列データの頻度変換

`tidyverse`と整合性がある金融時系列データ分析用のパッケージである`tidyquant`パッケージの`tq_transmute()`関数を用いて、時系列データの頻度変換（高頻度データから低頻度データへの変換）を行います。なお、`tidyquant`は頻度変換以外にも様々な分析機能があります。詳しくは[公式ウェブサイト](https://business-science.github.io/tidyquant/)を参照してください。

まず、使用するサンプルデータを作成します。`tq_transmute()`関数にわたす時系列データは、原則として横型データである点に留意してください。

```{r}
# サンプルデータ（日次）
data_owid_cases_wide <- data_owid %>% 
  dplyr::select(location, date, new_cases) %>% 
  dplyr::filter(date >= "2021-01-01") %>% 
  dplyr::arrange(date) %>% 
  tidyr::pivot_wider(id_cols = "date", names_from = "location", values_from = "new_cases")
```

### 日次データを週次データに変換 {.unnumbered}

`tidyquant::tq_transmute()`関数を使用して日次データを週次データに変換すると、月曜～日曜のデータが`FUN`に指定した関数で集計され、日曜の日付で記録されます。

```{r}
data_owid_cases_wide %>% 
  tidyquant::tq_transmute(select = -date, mutate_fun = apply.weekly, FUN = mean, na.rm = TRUE)
```

なお、日曜～土曜のデータを集計し日曜の日付で記録したい場合は、`rollmean()`関数を使用して前方7日移動平均を計算し、日曜の値を抽出します。

```{r}
data_owid_cases_wide %>%
  dplyr::mutate(across(-date, rollmean, k = 7, na.pad = TRUE, align = "left")) %>% 
  dplyr::filter(lubridate::wday(date) == 1)
```

### 日次データを月次データに変換 {.unnumbered}

`tidyquant::tq_transmute()`関数を使用して日次データを月次データに変換すると、月初～月末のデータが`FUN`に指定した関数で集計され、月末の日付で記録されます。

```{r}
data_owid_cases_wide %>% 
  tidyquant::tq_transmute(select = -date, mutate_fun = apply.monthly, FUN = mean, na.rm = TRUE)
```

### 日次データを四半期データに変換 {.unnumbered}

`tidyquant::tq_transmute()`関数を使用して日次データを四半期データに変換すると、期初～期末のデータが`FUN`に指定した関数で集計され、期末の日付で記録されます。

```{r}
data_owid_cases_wide %>% 
  tidyquant::tq_transmute(select = -date, mutate_fun = apply.quarterly, FUN = mean, na.rm = TRUE)
```
