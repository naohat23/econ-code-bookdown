# 時系列分析

第8章「時系列分析」では、時系列データを対象とする分析手法について解説します。

時系列分析は、観測値と観測時点がセットになった時系列データについて、観測時点間のデータの関係性（データの並び順や前後関係に関する性質）を明らかにしたり、過去のデータの特徴から将来の値を予測したりすることを目的としています。

なお、この章の説明は、Nielsen（2021）、西山 他（2019）、村尾（2019）、横内・青木（2014）を参考にしています。詳細は各参考文献を参照してください。

## 第8章の準備

### パッケージのインポート {.unnumbered}

```{r}
library(estimatr)
library(magrittr)
library(tidyverse)
library(vars)
library(urca)
```

### 外部データセットの取得 {.unnumbered}

この章では、西山 他（2019）の実証例のデータセットを使用します。[西山 他（2019）のサポートウェブサイト](http://www.yuhikaku.co.jp/books/detail/9784641053854)からデータファイルを取得し、各自の実行環境のワーキングディレクトリ直下に`data_nishiyama`フォルダを作成して、その中に格納してください。

## 定常性

時系列分析の目的は時系列データの特徴を明らかにし、将来の予測に役立てることです。そのためには、分析対象である時系列データの特徴が時間を通じて安定している必要があります。そうした時系列データの安定性を担保する前提条件が**定常性（stationarity）**です。

### 定常性の定義 {-}

本書では、定常性を次のように「平均$E(Y_t)$、分散$Var(Y_t)$、自己共分散$Cov(Y_t, Y\_{t-j})$が時間$t$を通じて変わらないこと」と定義します。このような性質をもつ時系列データを**定常過程（stationary process）**といいます。

特に、原系列に何ら変換を加えない状態で定常である時系列データを**レベル定常過程**と呼びます。レベル定常過程のデータは、ある水準の周りで安定的に推移し、一定の幅をもって変動します。

$$
E(Y_t) = \mu \lt \infty \\
Var(Y_t) = E[(Y_t - \mu)^2] = \sigma^2 \lt \infty \\
Cov(Y_t, Y_{t-j}) = E[(Y_t - \mu)(Y_{t-j} - \mu)] = \gamma_j, \quad j \gt 0
$$

なお、定常性にはいくつかの定義があり、本書では「弱定常」や「共分散定常」と呼ばれる定常性の定義を採用しています。定常性の詳細については、Nielsen（2021）P.77、西山 他（2019）P.476、村尾（2019）P.36、横内・青木（2014）P.82を参照してください。

### ホワイトノイズ {.unnumbered}

定常な時系列データの中でも、最も簡単で重要な系列が**ホワイトノイズ（white noise）**です。次のように「平均が0、分散がある一定の値、自己共分散が0」が成立する時系列データ$u_t$をホワイトノイズと定義します。ホワイトノイズの厳密な定義については、村尾（2019）P.32を参照してください。

$$
E(u_t) = 0 \\
Var(u_t) = E(u_t u_t) = \sigma^2 \lt \infty \\
Cov(u_t, u_s) = E(u_t, u_s) = 0, \quad t \ne s
$$

例えば、平均が0の正規分布（標準正規分布など）に従う時系列データはホワイトノイズの一種です。ホワイトノイズを生成する場合、`rnorm()`関数などを用いて正規乱数を生成し、ホワイトノイズとして利用することが一般的です。

```{r}
# 標準正規分布に従うサンプル数400の乱数を生成し折れ線グラフをプロット
rnorm(n = 400, mean = 0, sd = 1) %>% 
  plot(type = "l")
```

### 単位根 {-}

時系列データの安定性を示す定常性とコインの裏表の関係にある概念が、**単位根（unit root）**です。時系列データが定常か非定常かを判断するうえでは、単位根の有無が重要です。

ある時系列データ$Y_t$の当期の値$Y_t$と1期前の値$Y_{t-1}$について、次のような関係を考えます。なお、$u_t$はホワイトノイズです。

$$
Y_t = \rho Y_{t-1} + u_t 
$$

ここで、ある時に変数$u_t$に生じたショックがその後の時系列データ$Y_t$に与える波及効果は、データの時間を通じた影響力を表す係数$\rho$の絶対値$|\rho|$が取りうる範囲によって、次の3つに分類できます。

1.  $|\rho| \lt 1$のケース

    データの時間を通じた影響力が1より小さく、変数$u_t$に生じたショックは時間の経過に伴って減衰します。すなわち、[波及効果は過渡的・一時的であり、このケースは定常過程になります]{.underline}。

2.  $|\rho| = 1$のケース

    データの時間を通じた影響力が1であり、変数$u_t$に生じたショックは時間の経過に伴って減衰することなく一定で永遠に続きます。すなわち、[波及効果は恒久的であり、このケースは非定常過程になります]{.underline}。このように$|\rho| = 1$となる$\rho$を**単位根**といいます。このケースは**ランダムウォーク（random walk）**とも呼ばれます。

3.  $|\rho| \gt 1$のケース

    データの時間を通じた影響力が1より大きく、変数$u_t$に生じたショックは時間の経過に伴って拡大します。すなわち、[波及効果は爆発的（発散）であり、このケースは非定常過程になります]{.underline}。

本書では2のケースと3のケースが成立するとき、すなわち$|\rho| \ge 1$の場合に、当該データが**単位根過程（unit root process）**であると呼びます。単位根過程は非定常過程の十分条件です。また、単位根過程は次に示す階差定常過程と同義です。

### 和分過程 {.unnumbered}

分析対象の時系列データが非定常過程の場合、そのままでは一般的な時系列分析の手法を適用することができません。したがって、何らかの方法で非定常過程の定常化を行う必要があります。定常化の方法は、非定常過程の性質によって大きく2つに分けられます。

1.  トレンド定常過程（trend stationary）

    タイムトレンド（時間のみの関数）を取り除くことによって定常になる非定常過程は**トレンド定常過程**といいます。トレンド定常過程のデータはタイムトレンドの周りで安定的に推移し、一定の幅をもって変動します。トレンド定常過程では平均値が時間を通じて一定でないため、そのままでは定常ではありません。しかし、トレンド定常過程はレベル定常過程にタイムトレンドを加えただけであり、レベル定常過程と同様に$|\rho| \lt 1$のケースに該当するため、定常過程に近い性質であると言えます。

2.  階差定常過程（difference stationary）

    階差を取ることで定常になる非定常過程は**階差定常過程**といい、$|\rho| \ge 1$のケースに該当します。階差定常過程は「何回階差を取れば定常過程になるか」が重要になります。非定常過程$Y_t$が1次の階差変換で定常になるとき、$Y_t$は1次の**和分過程（integrated process）**であるといい、$Y_t \sim I(1)$と表記します。同様に2次の階差変換で定常になる場合は2次の和分過程と呼び$Y_t \sim I(2)$と表記します。和分過程のデータは時間の経過に伴ってコーン状に広がり、分散が限りなく大きくなります。また、和分過程のデータはタイムトレンドを取り除くだけでは定常になりません。

原系列のままで定常なレベル定常過程や、トレンド定常過程は、$I(0)$過程に分類されます。経済・金融分野では一般的に多くの時系列データが$I(0)$過程もしくは$I(1)$過程であり、$I(2)$過程はきわめて稀です。したがって実務的には$I(0)$過程と$I(1)$過程を見分けることが重要になります。

### 単位根検定（ADF検定） {.unnumbered}

分析対象の時系列データに単位根があるかどうかを判断するための方法が**単位根検定（unit root test）**です。単位根検定にはいくつかの種類がありますが、ここでは最も一般的な拡張ディッキー＝フラー検定（Augmented Dickey-Fuller test、ADF検定）を用います。ADF検定の最終的な目的は、単位根の有無をもとに、分析対象である時系列データの和分次数（$I(0)$、$I(1)$、$I(2)$など）を判断することです。

ADF検定では、分析対象の時系列データが定数項やタイムトレンド項をもつ可能性を考慮し、次の3種類のモデルについて「単位根がある（$\rho = 1$）」ことを帰無仮説とする検定を行います。ここで、定数項は$\beta_1$、タイムトレンド項は$\beta_2t$です。また、$\sum^{p-1}_{i=1}{\gamma_iY_{t-i}}$は系列相関の影響を制御（除去）する役割があります。

1.  trendモデル

    trendモデルは定数項$\beta_1$とタイムトレンド項$\beta_2t$の両方を含む回帰モデルです。

$$
\Delta{Y_t} = \beta_1 + \beta_2t + (\rho - 1)Y_{t-1} + \sum^{p-1}_{i=1}{\gamma_iY_{t-i}} + u_t
$$

2.  driftモデル

    driftモデルは定数項$\beta_1$を含む回帰モデルです。

$$
\Delta{Y_t} = \beta_1 + (\rho - 1)Y_{t-1} + \sum^{p-1}_{i=1}{\gamma_iY_{t-i}} + u_t
$$

3.  noneモデル

    noneモデルは定数項もタイムトレンド項も含まない回帰モデルです。

$$
\Delta{Y_t} = (\rho - 1)Y_{t-1} + \sum^{p-1}_{i=1}{\gamma_iY_{t-i}} + u_t
$$

ADF検定の具体的なフローは次のとおりです。

まず、時系列データの原系列に対し、trendモデル、driftモデル、noneモデルの順番で「単位根がある（$\rho = 1$）」ことを帰無仮説とする検定を行います。帰無仮説が棄却できればそこでADF検定が終了し、時系列データが$I(0)$過程であると判断します。

一方、3つのモデル全てにおいて帰無仮説が棄却できなければ、時系列データを階差変換し、再びtrendモデル、driftモデル、noneモデルの順番で検定を繰り返します。1次の階差変換で帰無仮説が棄却できれば時系列データは$I(1)$過程、2次の階差変換で帰無仮説が棄却できれば時系列データは$I(2)$過程と判断します。

なお、上記のフローは単純化したもので、実際には3つのモデルそれぞれについて複数の帰無仮説を検定し、その結果によって手順が変わる枝分かれのフロー構造になっています。ADF検定フローの詳細については、村尾（2019）P.137を参照してください。

### ADF検定フローの自作関数 {.unnumbered}

このように、ADF検定を用いた和分次数の判断はシステマチックに実施することができます。本書では、このADF検定フローを分析対象の時系列データに自動で適用する自作関数`adf_test_flow()`を定義します。

`adf_test_flow()`関数の`y`引数に時系列データを、その他の引数に各種条件を設定すると、ADF検定フローの結果を記載したtibble形式のデータフレームが返ります。

```{r}
# 時系列データに対しADF検定フローを自動で適用する関数
adf_test_flow <- function(y, diff = 0, selectlags = "AIC", lags = 1, sig_level = 0.05) {
  
  '
  y：ADF検定を適用する時系列データ（数値型ベクトル、ts型データ）
  diff：階差次数。デフォルト値は0
  selectlags：ラグ次数選択基準（"Fixed", "AIC", "BIC"）。デフォルト値は"AIC"
  lags：検定するモデルのラグ次数（正の整数）。デフォルト値は1。2以上を指定するとselectlags引数が自動で"Fixed"になる
  sig_level：有意水準（0.01, 0.05, 0.1）
  '
  
  # 引数diffの回数分yを階差変換
  d <- diff
  while (d > 0) {
    y <- diff(y, lag = 1)
    d <- d - 1
  }
  
  # 引数lagsが2以上であれば引数selectlagsを"Fixed"にする
  if (lags >= 2) {selectlags <- "Fixed"}
  
  # 引数sig_levelをurca::ur_df()関数用に文字列へ変換
  sig_level_str <- str_c(sig_level * 100, "pct")
  
  # 出力用tibble
  res <- tibble::tibble() %>% 
    dplyr::mutate(`フロー` = NA_real_,
                  `階差次数` = NA_real_,
                  `モデル` = NA_character_,
                  `ラグ次数` = NA_real_,
                  `帰無仮説` = NA_character_,
                  `検定統計量` = NA_character_,
                  `棄却点の分布` = NA_character_,
                  `検定値` = NA_real_,
                  `棄却点` = NA_real_,
                  `結果` = NA_character_,
                  `判断` = NA_character_,
                  `判断経路` = NA_character_,
                  )
  
  # フロー経路記入用ベクトルとフロー記入可否フラグ
  flow <- rep(FALSE, times = 7)
  flow[1] <- TRUE
  
  flow_cont <- TRUE
  
  # 正規分布の棄却点
  norm_cval <- qnorm(p = sig_level, lower.tail = TRUE)
  
  # ADF検定
  urdf_trend <- urca::ur.df(y, type = "trend", lags = lags, selectlags = selectlags)
  urdf_drift <- urca::ur.df(y, type = "drift", lags = lags, selectlags = selectlags)
  urdf_none <- urca::ur.df(y, type = "none", lags = lags, selectlags = selectlags)
  
  # フローカウンタ
  i <- 0
  
  # ADF検定フロー1 trendモデル H0：ρ - 1 = 0
  i <- i + 1
  res %<>% tibble::add_row(`フロー` = i,
                           `階差次数` = diff,
                           `モデル` = "trend 第1検定",
                           `ラグ次数` = nrow(urdf_trend@testreg$coefficients) - 3,
                           `帰無仮説` = "単位根あり",
                           `検定統計量` = "tau3",
                           `棄却点の分布` = "tau3",
                           `検定値` = urdf_trend@teststat[, "tau3"],
                           `棄却点` = urdf_trend@cval["tau3", sig_level_str],
                           `判断経路` = if_else(flow[i], "＊", NA_character_)
                           )
  if (urdf_trend@teststat[, "tau3"] < urdf_trend@cval["tau3", sig_level_str]) {
    res$結果[i] <- "帰無仮説を棄却"
    res$判断[i] <- str_c("単位根なし：I(", diff, ")過程")
    if (flow[i]) {flow_cont <- FALSE}
  } else {
    res$結果[i] <- "帰無仮説を棄却できない"
    res$判断[i] <- "単位根の判断保留：フロー2へ進む"
    if (flow_cont) {flow[2] <- TRUE}
  }
  
  # ADF検定フロー2 trendモデル H0：β2 = 0 and ρ - 1 = 0
  i <- i + 1
  res %<>% tibble::add_row(`フロー` = i,
                           `階差次数` = diff,
                           `モデル` = "trend 複合検定",
                           `ラグ次数` = nrow(urdf_trend@testreg$coefficients) - 3,
                           `帰無仮説` = "トレンド項なし＆単位根あり",
                           `検定統計量` = "phi3",
                           `棄却点の分布` = "phi3",
                           `検定値` = urdf_trend@teststat[, "phi3"],
                           `棄却点` = urdf_trend@cval["phi3", sig_level_str],
                           `判断経路` = if_else(flow[i], "＊", NA_character_)
                           )
  if (urdf_trend@teststat[, "phi3"] > urdf_trend@cval["phi3", sig_level_str]) {
    res$結果[i] <- "複合帰無仮説を棄却"
    res$判断[i] <- "トレンド項あり：フロー3へ進む"
    if (flow_cont) {flow[3] <- TRUE}
  } else {
    res$結果[i] <- "複合帰無仮説を棄却できない"
    res$判断[i] <- "トレンド項なし：フロー4へ進む"
    if (flow_cont) {flow[4] <- TRUE}
  }

  # ADF検定フロー3 trendモデル H0：ρ - 1 = 0
  i <- i + 1
  res %<>% tibble::add_row(`フロー` = i,
                           `階差次数` = diff,
                           `モデル` = "trend 第2検定",
                           `ラグ次数` = nrow(urdf_trend@testreg$coefficients) - 3,
                           `帰無仮説` = "単位根あり",
                           `検定統計量` = "tau3",
                           `棄却点の分布` = "正規分布",
                           `検定値` = urdf_trend@teststat[, "tau3"],
                           `棄却点` = norm_cval,
                           `判断経路` = if_else(flow[i], "＊", NA_character_)
                           )
  if (urdf_trend@teststat[, "tau3"] < norm_cval) {
    res$結果[i] <- "帰無仮説を棄却"
    res$判断[i] <- str_c("単位根なし：I(", diff, ")過程")
    if (flow[i]) {flow_cont <- FALSE}
  } else {
    res$結果[i] <- "帰無仮説を棄却できない"
    res$判断[i] <- "階差変換し再検定"
  }

  # ADF検定フロー4 driftモデル H0：ρ - 1 = 0
  i <- i + 1
  res %<>% tibble::add_row(`フロー` = i,
                           `階差次数` = diff,
                           `モデル` = "drift 第1検定",
                           `ラグ次数` = nrow(urdf_drift@testreg$coefficients) - 2,
                           `帰無仮説` = "単位根あり",
                           `検定統計量` = "tau2",
                           `棄却点の分布` = "tau2",
                           `検定値` = urdf_drift@teststat[, "tau2"],
                           `棄却点` = urdf_drift@cval["tau2", sig_level_str],
                           `判断経路` = if_else(flow[i], "＊", NA_character_),
                           )
  if (urdf_drift@teststat[, "tau2"] < urdf_drift@cval["tau2", sig_level_str]) {
    res$結果[i] <- "帰無仮説を棄却"
    res$判断[i] <- str_c("単位根なし：I(", diff, ")過程")
    if (flow[i]) {flow_cont <- FALSE}
  } else {
    res$結果[i] <- "帰無仮説を棄却できない"
    res$判断[i] <- "単位根の判断保留：フロー5へ進む"
    if (flow_cont) {flow[5] <-TRUE}
  }

  # ADF検定フロー5 driftモデル H0：β1 = 0 and ρ - 1 = 0
  i <- i + 1
  res %<>% tibble::add_row(`フロー` = i,
                           `階差次数` = diff,
                           `モデル` = "drift 複合検定",
                           `ラグ次数` = nrow(urdf_drift@testreg$coefficients) - 2,
                           `帰無仮説` = "定数項なし＆単位根あり",
                           `検定統計量` = "phi1",
                           `棄却点の分布` = "phi1",
                           `検定値` = urdf_drift@teststat[, "phi1"],
                           `棄却点` = urdf_drift@cval["phi1", sig_level_str],
                           `判断経路` = if_else(flow[i], "＊", NA_character_)
                           )
  if (urdf_drift@teststat[, "phi1"] > urdf_drift@cval["phi1", sig_level_str]) {
    res$結果[i] <- "複合帰無仮説を棄却"
    res$判断[i] <- "定数項あり：フロー6へ進む"
    if (flow_cont) {flow[6] <- TRUE}
  } else {
    res$結果[i] <- "複合帰無仮説を棄却できない"
    res$判断[i] <- "定数項なし：フロー7へ進む"
    if (flow_cont) {flow[7] <- TRUE}
  }

  # ADF検定フロー6 driftモデル H0：ρ - 1 = 0
  i <- i + 1
  res %<>% tibble::add_row(`フロー` = i,
                           `階差次数` = diff,
                           `モデル` = "drift 第2検定",
                           `ラグ次数` = nrow(urdf_drift@testreg$coefficients) - 2,
                           `帰無仮説` = "単位根あり",
                           `検定統計量` = "tau2",
                           `棄却点の分布` = "正規分布",
                           `検定値` = urdf_drift@teststat[, "tau2"],
                           `棄却点` = norm_cval,
                           `判断経路` = if_else(flow[i], "＊", NA_character_)
                           )
  if (urdf_drift@teststat[, "tau2"] < norm_cval) {
    res$結果[i] <- "帰無仮説を棄却"
    res$判断[i] <- str_c("単位根なし：I(", diff, ")過程")
    if (flow[i]) {flow_cont <- FALSE}
  } else {
    res$結果[i] <- "帰無仮説を棄却できない"
    res$判断[i] <- "階差変換し再検定"
  }

  # ADF検定フロー7 noneモデル H0：ρ - 1 = 0
  i <- i + 1
  res %<>% tibble::add_row(`フロー` = i,
                           `階差次数` = diff,
                           `モデル` = "none",
                           `ラグ次数` = nrow(urdf_none@testreg$coefficients) - 1,
                           `帰無仮説` = "単位根あり",
                           `検定統計量` = "tau1",
                           `棄却点の分布` = "tau1",
                           `検定値` = urdf_none@teststat[, "tau1"],
                           `棄却点` = urdf_none@cval["tau1", sig_level_str],
                           `判断経路` = if_else(flow[i], "＊", NA_character_)
                           )
  if (urdf_none@teststat[, "tau1"] < urdf_none@cval["tau1", sig_level_str]) {
    res$結果[i] <- "帰無仮説を棄却"
    res$判断[i] <- str_c("単位根なし：I(", diff, ")過程")
    if (flow[i]) {flow_cont <- FALSE}
  } else {
    res$結果[i] <- "帰無仮説を棄却できない"
    res$判断[i] <- "階差変換し再検定"
  }
  
  # 結果
  return(res)
}
```

### 村尾 実証例6.10 ADF検定 {-}

定義した自作関数`adf_test_flow()`を用い、`vars`パッケージの`Canada`データセットに含まれるカナダの実質労働生産性（`prod`）データに対して実際にADF検定フローを適用します（村尾（2019）P.141）。ラグ次数選択基準の`selectlags`には赤池情報量基準を意味する`"AIC"`を指定しておきます。

`adf_test_flow()`関数を適用した結果、実質労働生産性の原系列では単位根の存在が示唆され、1次の階差系列では単位根がないことが確認できました。したがって実質労働生産性は$I(1)$過程であると判断できます。

```{r}
# Canadaデータセットを呼び出し
data(Canada)

# 実質労働生産性データを変数yに格納しプロット
y <- Canada[, "prod"]
plot(y)

# yに原系列と階差次数1次でadf_test_flow()関数を適用
adf_prod_0 <- adf_test_flow(y = y, # 検定対象の時系列データ
                            diff = 0, # 階差次数
                            selectlags = "AIC", # ラグ次数選択基準
                            sig_level = 0.05 # 有意水準（％）
                            )

adf_prod_1 <- adf_test_flow(y = y, # 検定対象の時系列データ
                            diff = 1, # 階差次数
                            selectlags = "AIC", # ラグ次数選択基準
                            sig_level = 0.05 # 有意水準（％）
                            )

# 結果をコンソールに出力
# View(adf_prod) で別ウィンドウに結果を表示することも可能
adf_prod_0
adf_prod_1
```

## 系列相関

時系列データ$Y$について、現在の値$Y_t$と過去の値$Y_{t-1}$の間の相関を**系列相関（serial correlation）**もしくは**自己相関（autocorrelation）**といいます。

多くのマクロ経済データでは、正の系列相関（前期が正であれば今期も正である可能性が高い）が観察されます。系列相関がないデータは何らかのショックで平均値から乖離してもすぐにまた平均値へ戻りますが、正の系列相関があるデータは一度平均値を離れると戻るまでに一定期間を要する傾向があります。マクロ経済の活動が活発になる期間と停滞する期間が交互に繰り返される「景気循環」の現象は、マクロ時系列データ上では正の系列相関として表現されます（西村 他（2019）P.471）。

系列相関の有無やその構造を確認することは、分析対象である時系列データのモデリングやラグ次数の選択を行う上で重要です。また、最小2乗法（OLS）では誤差項に系列相関があると最小2条推定量の望ましい性質が得られないため、誤差項に対し系列相関の検定が行われます。これは後述するベクトル自己回帰（VAR）モデルでも同様です。

### 自己相関 {.unnumbered}

ラグ$j$の（標本）**自己相関係数**$\hat{\rho}_j$は、標本平均$\bar{Y} = (1/T)\Sigma^{T}_{t=1}{Y_t}$として、次のように計算できます。

$$
\hat{\rho}_{j} = \frac{\hat{\gamma}_{j}}{\hat{\gamma}_{0}} = \frac{\Sigma^{T}_{t=j+1}{(Y_t-\bar{Y})(Y_{t-j}-\bar{Y})}}{\Sigma^{T}_{t=1}{(Y_t-\bar{Y})^2}}
$$

**コレログラム（自己相関プロット）**は、横軸にラグ次数$j$、縦軸に自己相関係数の値をプロットした図で、`stats::acf()`関数で作成します。ACFはAuto Correlation Function（自己相関関数）を意味します。

コレログラム内に表示されている波線は「自己相関係数が0である」との帰無仮説をラグ次数$j = 1$から順番に逐次検定するための95％信頼区間を示しています。いずれかのラグ次数$j$において自己相関係数の値が信頼区間の外側にあれば、系列相関があると判断できます。

ここでは、西山 他（2019）P.478の図10-14で使用されている日本のGDPギャップ（内閣府、1980〜2016年）のデータでコレログラムを作成します。

```{r}
# XLSXデータを読み込み
data <- readxl::read_excel(path = "data_nishiyama/ch10/Fig_12_GDPgap_quarterly.xlsx", # ファイルパス（拡張子が必要、URLは不可）
                           sheet = NULL, # シートインデックス／シート名
                           col_names = c("year", "quarter", "date", "cao", "boj"), # ヘッダー（列名データ）の有無／列名指定
                           col_types = NULL, # 各列の型の指定（c：文字列型、d：数値型、D：日付型、l：論理値型）
                           skip = 1 # 読み込み時に上からスキップする行数
                           )

data %<>% 
  dplyr::select(date, cao, boj) %>% 
  dplyr::mutate(date = lubridate::date(zoo::as.yearqtr(date, format = "%YQ%q"))) %>% 
  dplyr::filter(date <= "2016-12-31")
```

`stats::acf()`関数でコレログラムを作成すると、ラグ次数が5次以下の低次の自己相関係数が有意であることが確認できます。このように、ラグ次数が低次の自己相関係数が正であり、ラグ次数1次をピークに単調に減少するのは、正の系列相関がある典型的なマクロ経済変数のコレログラムの例です。

しかし、これをもって、5四半期前までのGDPギャップが全て当該四半期のGDPギャップに関係しているとは判断できません。自己相関係数の計算では、ラグの積み重ねによる間接的な関係が含まれているためです。そうした間接的な影響を排除して、過去のデータと当月のデータの直接的な関係を調べる方法が、次の偏自己相関です。

```{r}
stats::acf(data$cao, plot = TRUE)
```

### 偏自己相関 {.unnumbered}

偏自己相関プロットを作成するには、`stats::pacf()`関数を使用します。PACFはPartial Auto Correlation Function（偏自己相関関数）を意味します。

自己相関プロットと同様に、日本のGDPギャップ（内閣府、1980〜2016年）のデータで偏自己相関プロットを作成すると、ラグ次数1次の偏自己相関係数が有意である一方、2〜5次の偏自己相関係数は有意ではなくなりました。この結果は、当該四半期のGDPギャップと関係しているのは1四半期前のGDPギャップのみであることを示しています。

```{r}
stats::pacf(data$cao, plot = TRUE)
```

### Ljung-Box検定 {.unnumbered}

自己相関プロットや偏自己相関プロットは系列相関の有無を視覚的に判断できる便利な方法ですが、プロット上に表示される95％信頼区間は逐次検定用であり、自己相関の数が大きくなると多重検定の問題が生じます（t検定を複数回行うと設定された有意水準5％よりも高い頻度で第1種の過誤が発生する）。つまり、実際には系列相関がないにも関わらず、どこかのラグ次数で帰無仮説（自己相関係数が0）を棄却してしまう確率が増加します（西村 他（2019））。

この問題を避けるには「複数の自己相関係数が0である」という結合帰無仮説

$$
H_0 : \rho_1 = \rho_2 = \cdots = \rho_m = 0
$$

を一度に検定する必要があります。対立仮説は「少なくとも一つの自己相関係数が0ではない」です。この結合帰無仮説の検定が、**リュン＝ボックス検定（Ljung-Box test）**です。なお、過去には「ダービン・ワトソン比」で系列相関の有無を判断する方法が用いられていましたが、現在ではLjung-Box検定を用いるのが一般的です（西村 他（2019）P.484）。

Ljung-Box検定を行うには`stats::Box.test()`関数を使用し、`type`引数に`"Ljung-Box"`を、`lag`引数にラグ次数を指定します。

実行すると、`X-squared`に修正Q統計量、`p-value`にp値が出力されます。この例ではp値が5％を大きく下回っており、ラグ次数が1のとき「系列相関がない」との帰無仮説が5％の有意水準で棄却されます。

```{r}
stats::Box.test(data$cao, lag = 1, type = "Ljung-Box")
```

一方、`rnorm()`関数で標準正規分布に従うデータを生成してLjung-Box検定を実行すると、p値が5％を大きく上回り「系列相関がない」との帰無仮説を5％の有意水準で棄却することができません。

```{r}
stats::Box.test(rnorm(n = 400, mean = 0, sd = 1), lag = 1, type = "Ljung-Box")
```

## 共和分

### 見せかけの回帰 {-}

2つの無関係な$I(1)$過程データを用いて回帰分析を行うと、データ間に関係がないにも関わらず回帰係数のt値や決定係数が大きくなり、「2つのデータに関係がある」と誤って判断してしまうことがあります。これを**見せかけの回帰（spurious regression）**といいます。

見せかけの回帰であると判断するポイントは、分析対象の時系列データの単位根検定と、回帰分析の結果得られる残差系列の診断です。

分析対象のデータに対し事前にADF検定行い、$I(0)$過程であると判断出来なければ、見せかけの回帰を疑う必要があります。

また、見せかけの回帰では残差が単位根をもつ$I(1)$過程になるため、残差に対しADF検定を行い単位根の有無を確認します。加えて、見せかけの回帰では残差が大きな系列相関をもつ症状があり、偏自己相関プロットやLjung-Box検定で系列相関を確認します。

### 西村 実証例12.3 見せかけの回帰 {-}

次の例は、西山 他（2019）P.592に掲載されている実証例12.3を参考に、1982〜2014年の日本の実質GDPを南極のペンギンの数に回帰したものです（どちらも原系列）。

なお、データ原系列の単位根検定を行うと、実質GDPはnoneモデルの検定において1％の有意水準で「単位根あり」の帰無仮説を棄却できないため（noneモデルはADF検定フローの判断経路上にないものの）$I(0)$過程と判断するのは留保した方が良いでしょう。ペンギン数は全てのモデルで帰無仮説を棄却できず、$I(0)$過程とは判断出来ません。

回帰分析の結果、日本の実質GDPと南極のペンギンの数には何ら関係がないにも関わらず、ペンギン数の回帰係数は1％の有意水準で有意に正であり、自由度修正済み決定係数は0.50とまずまずの大きさになっています。

一方、残差系列にADF検定を適用すると1％の有意水準で「単位根あり」の帰無仮説を棄却できず、残差が単位根をもつと判断できます。また、残差系列の偏自己相関プロットを作成するとラグ次数1次の偏自己相関係数が有意に正であり、正の自己相関があることが示唆されます。また、Ljung-Box検定の結果を見るとp値が1％を下回り、1％の有意水準で系列相関があると判断できます。こうした残差に関する診断も、この例が見せかけの回帰であることを支持しています。

```{r}
# XLSXデータを読み込み
data <- readxl::read_excel(path = "data_nishiyama/ch12/Fig_2_penguin.xlsx", # ファイルパス（拡張子が必要、URLは不可）
                           sheet = "Figure", # シートインデックス／シート名
                           col_names = c("date", "gdp", "penguin"), # ヘッダー（列名データ）の有無／列名指定
                           col_types = NULL, # 各列の型の指定（c：文字列型、d：数値型、D：日付型、l：論理値型）
                           skip = 1 # 読み込み時に上からスキップする行数
                           )

# 単位根検定
adf_gdp_0 <- adf_test_flow(y = data$gdp, # 検定対象の時系列データ
                           diff = 0, # 階差次数
                           selectlags = "AIC", # ラグ次数選択基準
                           sig_level = 0.01 # 有意水準（％）
                           )

adf_penguin_0 <- adf_test_flow(y = data$penguin, # 検定対象の時系列データ
                               diff = 0, # 階差次数
                               selectlags = "AIC", # ラグ次数選択基準
                               sig_level = 0.01 # 有意水準（％）
                               )

adf_gdp_0
adf_penguin_0

# estimatr::lm_robust()関数でgdpをpenguinに回帰
result <- estimatr::lm_robust(formula = gdp ~ penguin,
                              data = data,
                              se_type = "HC1", # 標準誤差の設定（classical, HC0, HC1, HC2, HC3, CR0, CR2）
                              alpha = 0.01 # 有意水準
                              )

summary(result)

# 残差系列をresidに格納
resid <- data$gdp - result$fitted.values

# 残差の単位根検定
adf_resid <- adf_test_flow(y = resid, # 検定対象の時系列データ
                           diff = 0, # 階差次数
                           selectlags = "AIC", # ラグ次数選択基準
                           sig_level = 0.01 # 有意水準（％）
                           )

adf_resid

# 残差の偏自己相関プロット
stats::pacf(resid, plot = TRUE)

# 残差のLjung-Box検定
stats::Box.test(resid, lag = 1, type = "Ljung-Box")
```

### 共和分関係 {-}

見せかけの回帰とは異なり、複数の$I(1)$過程のデータの間に意味のある関係を見出すことができる場合があります。そうした関係を**共和分（cointegration）**といいます。

共和分は、$I(1)$過程の2つのデータ$Y_t \sim I(1)$と$X_t \sim I(1)$の線型結合が$I(0)$過程に従うこと、すなわち、

$$
\beta_1 Y_t + \beta_2 X_t \sim I(0)
$$

を満たす$\beta_1$と$\beta_2$が存在することと定義されます。これは、

$$
Y_t = \mu + \theta X_t + u_t
$$

を最小2乗法（OLS）で推定して得られる残差$\hat{u}_t = Y_t - \hat{\mu} - \hat{\theta} X_t$が$I(0)$過程に従うことを意味します。したがって、見せかけの回帰と共和分は「残差が$I(1)$過程であれば見せかけの回帰」、「残差が$I(0)$過程であれば共和分」と区別できます。

### Engle-Granger検定 {-}

最小二乗法で推定した残差の性質を利用した共和分の検定方法が、**エングル＝グレンジャー検定（Engle-Granger test）**です。

```{r}
# Canadaデータセットを呼び出し
data(Canada)

```


## 1変数時系列モデル

### ARモデル {.unnumbered}

### MAモデル {.unnumbered}

### ARMAモデル {.unnumbered}

### ARIMAモデル {.unnumbered}

## 多変数時系列モデル

### ADLモデル {.unnumbered}

### 誤差修正モデル {.unnumbered}

## VARモデル

## 時系列分析のフローチャート
