# Rの基本的な使用方法

本節では、Rの基本的な使用方法について解説します。本節の内容は基礎部分のみのため、詳細は、[馬場真哉（2020）『R言語ではじめるプログラミングとデータ分析』](https://www.socym.co.jp/book/1238)や、[Hadley Wickham、Garrett Grolemund（2017）『Rではじめるデータサイエンス』](https://www.oreilly.co.jp/books/9784873118147/)などを参照してください。

RStudioでコードを編集するパネルをソース（Source）と呼びます。RStudioの左上のパネルがソースで、コンソール（Console）パネルの上にあります。ソースが表示されていない場合は、FileメニューからNew Fileに進み、R Scriptを選択すると、ソースが表示されます。

ソースにコードを記述し、記述したコードの行にカーソルがある状態で`Ctrl + Enter`を押すと、コンソールに実行結果が表示されます。

## 主要ショートカットキー

-   `Alt + Shift + K`：キーボードショートカットを表示

### 編集 {-}

-   `Ctrl + S`：保存
-   `Ctrl + A`：すべて選択
-   `Ctrl + Shift + R`：セクション区切りを挿入
-   `Ctrl + Shift + C`：選択範囲をコメントアウト／コメントアウト解除
-   `Ctrl + Shift + M`：パイプオペレータ`%>%`を挿入

### 実行 {-}

-   `Ctrl + Enter`：カーソルがある行／選択している部分のコードを実行
-   `Ctrl + Alt + T`：カーソルがあるセクションのコードをすべて実行
-   `Ctrl + Alt + R`：すべてのコードを実行

### その他 {-}

-   `F1`：カーソルがある関数のヘルプを表示

## 基本操作

```{r}
# 代入は <- か =
x <- 2
x

# シャープでコメントアウト（実行されない）
```

## 演算

### 四則計算 {.unnumbered}

```{r}
# 足し算
1 + 1

# 引き算
3 - 1

# 掛け算
2 * 3

# 割り算
10 / 5

# 割り算の整数の商
10 %/% 3

# 割り算の余り
10 %% 3

# べき乗
3 ** 2
3 ^ 2
```

### 数値計算 {.unnumbered}

```{r}
# 自然対数
log(10)

# ネイピア数のべき乗
exp(1)

# 平方根
sqrt(2)

# 絶対値
abs(-5)
```

### 一致・大小関係 {.unnumbered}

```{r}
# 一致
2 == 2

# 不一致
3 != 2

# より大きい
3 > 2

# 以上
3 >= 3

# より小さい
2 < 3

# 以下
2 <= 2
```

### 包含関係・集合関係 {.unnumbered}

```{r}
# 包含関係
1:5 %in% c(1, 2, 5)

# 和集合
union(seq(0, 20, 2), seq(0, 20, 3))

# 共通部分
intersect(seq(0, 20, 2), seq(0, 20, 3))

# 差分
setdiff(seq(0, 20, 2), seq(0, 20, 3))
```

## ベクトル

### ベクトルの作成 {.unnumbered}

ベクトルは複数の要素を一つにまとめたデータ構造で、`c()`関数で作成します。一つのベクトルには単一のデータ型のみ格納でき、数値型や文字列型のデータを混在させることはできません。

```{r}
# 数値型ベクトルの作成
vec_1 <- c(11, 12, 13, 14, 15)
vec_1

# 文字列型ベクトルの作成
vec_2 <- c("Hello", "World")
vec_2

# 数値型データと文字列型データを混在させると、すべて文字列型に変換される
c(1, 2, "A", "B")
```

### ベクトル要素へのアクセス {.unnumbered}

ベクトルでは、`ベクトル[要素のインデックス]`の形でインデックスを指定して各要素にアクセスすることができます。なお、Pythonなど他のプログラミング言語のインデックスは0から始まりますが、Rのインデックスは1から始まる点に注意してください。

```{r}
# ベクトルの要素へのアクセス
vec_1[1]
vec_1[5]
vec_1[2:4]
rev(vec_1)[1]
```

### 規則性があるベクトルの作成 {.unnumbered}

規則性があるベクトルを作成するには、コロン（`:`）、`seq()`関数、`rep()`関数を使用します。

```{r}
# 1から10までの等差数列
1:10

# 0から20までの2つ置きの数列
seq(from = 0, to = 20, by = 2)

# 1から10までを4等分する等差数列
seq(from = 1, to = 10, length.out = 4)

# 要素の繰り返し
rep(x = 2, times = 5)

# ベクトルの繰り返し
rep(x = c(1, 2), times = 3)

# ベクトルの各要素の繰り返し
rep(x = c(1, 2), each = 3)
```

### ベクトルの演算 {.unnumbered}

ベクトルの演算を行うと、ベクトルの対応する要素どうしが計算され、ベクトルが出力されます。ベクトルの長さが異なる場合は、短い方のベクトルが使いまわされて長さを合わせます。

`*`演算子はベクトルの要素どうしの掛け算を行う点に注意してください。ベクトルの内積を計算するには`%*%`演算子を使用します。

```{r}
vec_3 <- c(1, 2, 3)
vec_4 <- c(5, 6, 7)

# ベクトル要素の足し算
vec_3 + vec_4

# ベクトル要素の引き算
vec_3 - vec_4

# ベクトル要素の掛け算
vec_3 * vec_4

# ベクトル要素の割り算
vec_3 / vec_4

# ベクトルの内積
vec_3 %*% vec_4
```

## 行列

### 行列の作成 {.unnumbered}

行列は`matrix()`関数を使用し、ベクトルを複数の列・行に分割する形で作成します。

```{r}
# ベクトルを複数列に分割して行列を作成
mat_1 <- matrix(
  data = 1:10,
  ncol = 2
)

mat_1
```

```{r}
# ベクトルを複数行に分割して行列を作成
mat_2 <- matrix(
  data = 1:10,
  nrow = 2
)

mat_2
```

### 行列の要素へのアクセス {.unnumbered}

行列の要素にアクセスするには、ベクトルと同様に`行列[要素の行インデックス, 要素の列インデックス]`の形でインデックスを指定します。

```{r}
# 行列の3行目・1列目の要素を取得
mat_1[3, 1]

# 行列の4行目全体を取得
mat_1[4, ]

# 行列の2列目全体を取得
mat_1[, 2]

# 行列の1～3行目を取得
mat_1[1:3, ]

# 行列の1～3行目以外を取得
mat_1[-1:-3, ]
```

### 行列の演算 {.unnumbered}

行列の演算を行うと、行列の対応する要素どうしが計算され、行列が出力されます。

`*`演算子は行列の要素どうしの掛け算を行う点に注意してください。行列の積を計算するには`%*%`演算子を使用します。

```{r}
mat_2 <- matrix(
  data = 1:4,
  ncol = 2
)

mat_3 <- matrix(
  data = 5:8,
  ncol = 2
)

# 行列要素の足し算
mat_2 + mat_3

# 行列要素の引き算
mat_2 - mat_3

# 行列要素の掛け算
mat_2 * mat_3

# 行列要素の割り算
mat_2 / mat_3

# 各行の和
rowSums(mat_2)

# 各列の和
colSums(mat_2)

# 行列の積
mat_2 %*% mat_3

# 行列の転置
t(mat_2)

# 逆行列
solve(mat_2)
```

## データフレーム

データフレームは、同じ長さの列ベクトルを複数まとめた行列形式のデータ構造で、Rによる分析を行う上で最も頻繁に使用します。Excelのスプレッドシートのイメージに近く、実際にCSV形式のファイルをRに読み込むとデータフレーム形式のオブジェクトが作成されます。

なお、データフレームには、Rにもともと備わっている`data.frame`形式と、`tidyverse`パッケージによって導入された`tibble`形式の2種類があります。両者にはいくつか違いがありますが、`data.frame`形式を使いやすくしたものが`tibble`形式と言えます。詳細は`tibble`パッケージの[公式ウェブサイト](https://tibble.tidyverse.org/)を参照してください。

### データフレームの作成 {.unnumbered}

`tibble`形式のデータフレームは、`tibble()`関数を使用して`列名 = 要素`の形で作成します。データフレームではすべての列ベクトルの要素数が同じになるようにします。

```{r}
df_1 <- tibble(
  x = 1:5,
  y = 6:10,
  z = x ^ 2 + y 
)

df_1
```

### データフレームの要素へのアクセス {.unnumbered}

データフレームでは、`データフレーム$列名`の形で各列ベクトルにアクセスすることができます。また、`データフレーム$列名[要素インデックス]`で各列ベクトルの要素にアクセスできます。

```{r}
df_1$x
df_1$z[3]
```

また、角括弧を使用して要素にアクセスすることもできます。ここで、一重の角括弧と二重の角括弧では実行結果が異なる点に注意してください。一重角括弧では、結果が`tibble`形式で出力されます。一方、二重角括弧ではベクトルや単一の数値といった要素そのものが出力されます。

```{r}
df_1["x"]
df_1[1]
df_1[2, 2]

df_1[["x"]]
df_1[[1]]
df_1[[2, 2]]
```

### その他のデータフレームの機能 {-}

```{r}
df_2 <- tibble(
  letters = LETTERS,
  numbers = 1:26
)

df_2

# データフレームの上部のみ表示
head(df_2)

# データフレームの下部のみ表示
tail(df_2)

# データフレームの列名一覧を出力
colnames(df_2)
```

## リスト

リストは、単一の数値、文字列、ベクトル、データフレームなど、様々な種類のデータを格納することができる容器のようなものです。リストそのものをリストに格納することもできます。リストは`list()`関数で作成します。リストに格納する各要素には、それぞれ名前を付けることができます。

### リストの作成 {.unnumbered}

```{r}
list_1 <- list(
  number = 1,
  string = "a",
  vector = c(10, 11, 12),
  matrix = matrix(1:9, ncol = 3)
)

list_1
```

### リストの要素へのアクセス {.unnumbered}

リストでは、データフレームと同様に`リスト$要素名`の形でドルマークを使用して各要素にアクセスすることができます。

```{r}
list_1$number
list_1$matrix
```

また、ベクトルや行列と同様に、`リスト[[要素インデックス]]`でも各要素にアクセスすることができます。ここで、角括弧が二重である点に注意してください。

```{r}
list_1[[3]]
```

## 制御構文

制御構文には、条件分岐を行う`if`や`else`、同じ操作の繰り返しを行う`for`や`while`、エラー処理を行う`try`があります。

### if/else文 {.unnumbered}

`if`文は、`if (条件) {処理}`の形で記述します。`else if`で追加条件、`else`で「その他すべて」の場合を意味します。

```{r}
x <- 5

if (x < 2) {
  print("A")
} else if (x >= 2 & x < 6) {
  print("B")
} else {
  print("C")
}
```

### forループ {.unnumbered}

`for`文は、`for (変数 in 変数に逐次代入する要素) {処理}`の形で記述します。変数はカウンタではない点に注意してください。

```{r}
for (i in 1:5) {
  print(i)
}
```

```{r}
for (letter in letters[1:6]) {
  print(letter)
}
```

変数をカウンタとして使用する場合は、`seq_along()`関数を`for (変数 in seq_along(変数に逐次代入する要素を格納したベクトル等))`の形で用いると、自動的に要素数に応じたインデックスを変数に代入してくれます。

```{r}
for (i in seq_along(letters[1:6])) {
  print(str_c(i, "_", letters[1:6][i]))
}
```

### whileループ {-}

`while`文は、`while (繰り返し処理を続ける条件) {処理}`の形で記述します。「繰り返し処理を続ける条件」が有限回数で終わるように処理内容を工夫します。例えば、下記のように条件を「カウンタが正の値」にしておき、処理の中でカウンタが減少するように書くのが一般的です。

```{r}
count <- 3

while (count > 0) {
  print(count)
  count <- count - 1
}
```

### breakによる繰り返しの終了 {.unnumbered}

`while`文の処理の中で`break`文を用い、ループを強制的に終了させることができます。

```{r}
vec_break <- c(10, 20, 30, 40, 50)
index <- 1

while(TRUE) {
  # indexがvec_breakの要素数を超えると繰り返しを終了
  if (index > length(vec_break)) {
    break
  }
  print(vec_break[index])
  index <- index + 1
}
```

### tryによるエラー処理 {.unnumbered}

エラーを起こす可能性がある処理を`try()`関数の`expr = {}`内に記述することで、エラーが発生しても処理を続けることができます。

```{r}
list_try <- list(1, 2, 3, "4", 5)

for (i in seq_along(list_try)) {
  try(
    expr = {
      # エラーの可能性がある処理
      x <- log(list_try[[i]])
      print(x)
    },
    silent = FALSE # TRUEにするとエラーの内容を非表示
  ) 
}
```

## データの読み込み・書き出し

### CSVデータの読み込み {.unnumbered}

```{r, eval=FALSE}
data <- readr::read_csv(file = "directory/file.csv", # ファイルパス／URL（拡張子が必要）
                        col_names = TRUE, # ヘッダー（列名データ）の有無
                        col_types = NULL, # 各列の型の指定（c：文字列型、d：数値型、D：日付型、l：論理値型）
                        skip = 0) # 読み込み時に上からスキップする行数
```

### Excelデータの読み込み（xls形式） {.unnumbered}

`readr`パッケージの`read_excel()`関数はExcelのxls形式、xlsx形式どちらも読み込み可能です。ただし、読み込みができるのはローカルネットワーク内のファイルパスだけで、URLからの読み込みはできません。

```{r, eval=FALSE}
data <- readxl::read_excel(path = "directory/file.xls", # ファイルパス（拡張子が必要、URLは不可）
                           sheet = NULL, # シートインデックス／シート名
                           col_names = TRUE, # ヘッダー（列名データ）の有無
                           col_types = NULL, # 各列の型の指定（c：文字列型、d：数値型、D：日付型、l：論理値型）
                           skip = 0) # 読み込み時に上からスキップする行数
```

### Excelデータの読み込み（xlsx形式） {.unnumbered}

`openxlsx`パッケージの`read.xlsx()`関数であれば、ローカルネットワーク内のファイルパスとURLどちらからでも読み込みが可能です。ただし、読み込めるファイル形式はxlsx形式のみで、xls形式には対応していません。

```{r, eval=FALSE}
data <- openxlsx::read.xlsx(xlsxFile = "directory/file.xlsx", # ファイルパス／URL（拡張子が必要）
                            sheet = 1, # シートインデックス／シート名
                            startRow = 5, # 読み込み開始行
                            colNames = TRUE, # 列名データの有無
                            rowNames = FALSE, # 行名データの有無
                            rows = 5:53, # 読み込む列（NULLですべて読み込み）
                            cols = NULL) # 読み込む行（NULLですべて読み込み）
```

### CSVデータの書き出し {.unnumbered}

```{r, eval=FALSE}
write.csv(..., # 書き出すオブジェクト名（クオーテーションは不要）
          file = "directory/file.csv", # 書き出し先のファイルパス（拡張子が必要）
          row.names = FALSE) # 行番号を付与するか
```

## オブジェクトのセーブ・ロード

### セーブ {.unnumbered}

RのオブジェクトをRData形式で保存します。

```{r, eval=FALSE}
save(..., # セーブするオブジェクト名（クオーテーションは不要）
     file = "directory/file.RData") # セーブ先のファイルパス（拡張子が必要）
```

### ロード {.unnumbered}

保存したRData形式のオブジェクトを呼び出します。

```{r, eval=FALSE}
load(file = "directory/file.RData") # ロード元ファイルパス（拡張子が必要）
```

